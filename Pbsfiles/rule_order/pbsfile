# implementing rule order with a mini build system
	
	# rule [types, order], name, [depender], builders, node_subs ;

# first everything is a dependency
# first_plus, after first at given index (don't have to be continuous but must be numeric)

# last, is a dependency to everything
# last_minus, before last at given index

# before, is a dependent
# after is a dependency

# build sequence is, one possible, order of rules calling

sub add_rule ; sub generate_rules ;

#add_rule qw(a some_error) ; # ok

add_rule qw(first first) ;
# add_rule qw(second_first first) ; # ok
#add_rule qw(after_first after first) ; # ok
add_rule qw(before_first before first) ;

add_rule qw(last last) ;
#add_rule qw(before_last before last) ; # ok
add_rule qw(after_last after last) ;


add_rule qw(last_minus_2 last_minus 2) ;
#add_rule qw(last_minus_2_again last_minus 2) ; # ok
add_rule qw(last_minus_3 last_minus 3) ;
add_rule qw(last_minus_10 last_minus 10) ;
#add_rule qw(last_minus_10_again last_minus 10) ; # ok

add_rule qw(first_plus_0 first_plus 0) ;
#add_rule qw(first_plus_0_again first_plus 0) ; # ok
add_rule qw(first_plus_6 first_plus 6) ;
add_rule qw(first_plus_3 first_plus 3) ;


add_rule qw(before_b before b) ; 
add_rule qw(before_x before x) ; 

add_rule qw(after_c after c) ; # after b is an error as b is last
add_rule qw(after_y_z after y z) ; 

#add_rule qw(wrong order here) ; # ok

# cycle is an error
add_rule qw(cycle_1 before cycle_2) ;
add_rule qw(cycle_2 before cycle_3) ;
#add_rule qw(cycle_3 before cycle_1) ; # ok
# add_rule qw(cycle_2 after cycle_3) ; # ok

# rules are otherwise added in registration order, which is the same as g before h
add_rule qw(index_0) ;
add_rule qw(index_0 before before_first ) ; #we can have multiple position rules 
add_rule qw(index_1) ;
add_rule qw(index_2) ;

generate_rules ;

my %rules ;
my $rule_index = 0 ;

sub add_rule
{
my ($rule, $order, @rest) = @_ ;

if (@_ == 1)
	{
	# added in rule order
	$rules{$rule_index++} = $rule ;
	}
elsif (@_ == 2)
	{
	# first or last, we can check later if multiple are defined

	die ERROR "Rule: wrong order '$order' at rule: @_\n" unless $order eq 'first' or $order eq 'last' ;
	push @{$rules{$order}}, $rule ;
	}
else
	{
	# before or after

	die ERROR "Rule: wrong order '$order' at rule: @_\n" unless $order eq 'before' or $order eq 'after' or $order eq 'last_minus' or $order eq 'first_plus' ;

	if ($order eq 'before' or $order eq 'after')
		{
		push @{$rules{$order}{$rule}}, @rest ;
		}
	else
		{
		die ERROR "Rule: only one index allowed at rule: @_\n" if @rest > 1 ;

		push @{$rules{$order}{$rest[0]}}, $rule ;
		}

	}
}

sub generate_rules
{
my ($show_rules, $show_registration) = (GetConfig('show_rules:SILENT_NOT_EXISTS'), GetConfig('show_registration:SILENT_NOT_EXISTS')) ;

use Data::TreeDumper ;
PrintDebug DumpTree \%rules, 'rules' if $show_rules ;

die DumpTree($rules{first}, "Rule: multiple first") if exists $rules{first} && @{ $rules{first} } > 1 ;
die DumpTree($rules{last}, "Rule: multiple last") if exists $rules{last} && @{ $rules{last} } > 1 ;

my $first_rule = $rules{first}[0] // 'first';
my $last_rule = $rules{last}[0] // 'last' ;

my $added_rule = 0 ;
my %targets ;

# indexed rules
for (reverse 1 .. $rule_index - 1)
	{
	PrintDebug "Rule $added_rule, ['$rules{$_}' => '" . $rules{$_ - 1} ."'] ; # adding indexed rule\n" if $show_registration ;
	rule $added_rule++, [$rules{$_} => $rules{$_ - 1}] ;
	$targets{$rules{$_}}++ ;
	}

if ($rule_index > 0) # we have at least one indexed rule
	{
	PrintDebug "Rule $added_rule, ['$rules{0}' => '$last_rule'] ; # adding indexed rule\n" if $show_registration ;
	rule $added_rule++, [$rules{0} => $last_rule] ;
	$targets{$rules{0}}++ ;
	}

# first rule
for (0 .. $rule_index - 1)
	{
	PrintDebug "Rule $added_rule, ['$first_rule' => '$rules{$_}'] ; # adding first rule (indexed)\n" if $show_registration ;
	rule $added_rule++, [$first_rule => $rules{$_}] ;
	$targets{$first_rule}++ ;
	}

if (@{ $rules{last} })
	{
	PrintDebug "Rule $added_rule, ['$first_rule' => '$last_rule'] ; # adding first rule (last)\n" if $show_registration ;
	rule $added_rule++, [$first_rule => $last_rule] ;
	$targets{$first_rule}++ ;
	}

for my $rule (keys %{ $rules{after} })
	{
	PrintDebug "Rule $added_rule, ['$first_rule' => '$rule'] ; # adding first rule (after)\n" if $show_registration ;
	rule $added_rule++, [$first_rule => $rule] ;
	$targets{$first_rule}++ ;

	for (@{ $rules{after}{$rule} })
		{
		PrintDebug "Rule $added_rule, ['$first_rule' => '$_'] ; # adding first rule (after)\n" if $show_registration ;
		rule $added_rule++, [$first_rule => $_] ;
		$targets{$first_rule}++ ;
		}
	}

for my $rule (keys %{ $rules{before} })
	{
	PrintDebug "Rule $added_rule, ['$first_rule' => '$rule'] ; # adding first rule (before)\n" if $show_registration ;
	rule $added_rule++, [$first_rule => $rule] ;
	$targets{$first_rule}++ ;

	for (@{ $rules{before}{$rule} })
		{
		if ($first_rule ne $_)
			{
			PrintDebug "Rule $added_rule, ['$first_rule' => '$_'] ; # adding first rule (before)\n" if $show_registration ;
			rule $added_rule++, [$first_rule => $_] ;
			$targets{$first_rule}++ ;
			}
		}
	}

# after rules
for my $rule (keys %{ $rules{after} })
	{
	for (@{ $rules{after}{$rule} })
		{
		die "Rule: rule '$rule' can't be run after first rule '$first_rule'" if $_ eq $first_rule ;

		PrintDebug "Rule $added_rule, ['$rule' => '$_'] ; # adding after rule\n" if $show_registration ;
		rule $added_rule++, [$rule => $_] ;
		$targets{$rule}++ ;

		if($_ ne $last_rule)
			{ 
			PrintDebug "Rule $added_rule, ['$_' => '$last_rule'] ; # adding after rule\n" if $show_registration ;
			rule $added_rule++, [$_ => $last_rule] ;
			$targets{$_}++ ;
			}
		}

	PrintDebug "Rule $added_rule, ['$rule' => '$last_rule'] ; # adding after rule\n" if $show_registration ;
	rule $added_rule++, [$rule => $last_rule] ;
	$targets{$rule}++ ;
	}

# before rules
for my $rule (keys %{ $rules{before} })
	{
	for (@{ $rules{before}{$rule} })
		{
		die "Rule: rule '$rule' can't be run before last rule '$last_rule'" if $_ eq $last_rule ;

		PrintDebug "Rule $added_rule, ['$_' => '$rule'] ; # adding before rule\n" if $show_registration ;
		rule $added_rule++, [$_ => $rule] ;
		$targets{$_}++ ;

		PrintDebug "Rule $added_rule, ['$_' => '$last_rule'] ; # adding before rule\n" if $show_registration ;
		rule $added_rule++, [$_ => $last_rule] ;
		$targets{$_}++ ;
		}

	PrintDebug "Rule $added_rule, ['$rule' => '$last_rule'] ; # adding before rule\n" if $show_registration ;
	rule $added_rule++, [$rule => $last_rule] ;
	$targets{$rule}++ ;
	}

# first_plus rules
my @first_plus_indexes = sort {$a <=> $b } keys %{$rules{first_plus}} ;
for (0 .. $#first_plus_indexes)
	{
	my $rule_index = $first_plus_indexes[$_] ;
	die DumpTree($rules{first_plus}{$rule_index}, "Rule: multiple entries at first plus index $rule_index") if @{ $rules{first_plus}{$rule_index } } > 1 ;
	}

for (0 .. $#first_plus_indexes - 1)
	{
	my $rule_index = $first_plus_indexes[$_] ;
	my $next_rule_index = $first_plus_indexes[$_ + 1] ;

	# depend on each other
	PrintDebug "Rule $added_rule, ['$rules{first_plus}{$rule_index}[0]' => '$rules{first_plus}{$next_rule_index}[0]'] ; # adding first_plus rule\n" if $show_registration ;
	rule $added_rule++, [$rules{first_plus}{$rule_index}[0] => $rules{first_plus}{$next_rule_index}[0]] ;
	}

if (@first_plus_indexes)
	{
	my $rule_index = $first_plus_indexes[0] ;

	PrintDebug "Rule $added_rule, ['$first_rule' => '$rules{first_plus}{$rule_index}[0]'] ; # adding first_plus rule\n" if $show_registration ;
	rule $added_rule++, [$first_rule => $rules{first_plus}{$rule_index}[0]] ;

	my $last_rule_in_list = $rules{first_plus}{$first_plus_indexes[$#first_plus_indexes]}[0] ;

	#all nodes except those in list and first are dependencies to last in list
	for (grep {$_ ne $first_rule } keys %targets)
		{
		PrintDebug "Rule $added_rule, ['$last_rule_in_list' => '$_'] ; # adding first_plus rule:\n" if $show_registration ;
		rule $added_rule++, [$last_rule_in_list => $_] ;
		}

	# add rules to targets
	$targets{$_}++ for (keys %{$rules{first_plus}}) ;
	}

# last_minus rules
my @last_minus_indexes = sort {$a <=> $b } keys %{$rules{last_minus}} ;
for (0 .. $#last_minus_indexes)
	{
	my $rule_index = $last_minus_indexes[$_] ;
	die DumpTree($rules{last_minus}{$rule_index}, "Rule: multiple entries at last minus index $rule_index") if @{ $rules{last_minus}{$rule_index } } > 1 ;
	}

for (reverse 1 .. $#last_minus_indexes)
	{
	my $rule_index = $last_minus_indexes[$_] ;
	my $previous_rule_index = $last_minus_indexes[$_ - 1] ;

	# depend on each other
	PrintDebug "Rule $added_rule, ['$rules{last_minus}{$rule_index}[0]' => '$rules{last_minus}{$previous_rule_index}[0]'] ; # adding last_minus rule:\n" if $show_registration ;
	rule $added_rule++, [$rules{last_minus}{$rule_index}[0] => $rules{last_minus}{$previous_rule_index}[0]] ;
	}

if (@last_minus_indexes)
	{
	# first rule in list depends on "last"
	my $rule_index = $last_minus_indexes[0] ;

	PrintDebug "Rule $added_rule, ['$rules{last_minus}{$rule_index}[0]' => '$last_rule'] ; # adding last_minus rule\n" if $show_registration ;
	rule $added_rule++, [$rules{last_minus}{$rule_index}[0] => $last_rule] ;

	#all other rules depend on first in this list
	my $first_rule_in_list = $rules{last_minus}{$last_minus_indexes[$#last_minus_indexes]}[0] ;

	for (grep {$_ ne $last_rule } keys %targets)
		{
		PrintDebug "Rule $added_rule, ['$_' => '$first_rule_in_list'] ; # adding last_minus rule\n" if $show_registration ;
		rule $added_rule++, [$_ => $first_rule_in_list] ;

		}
	# add rules to targets
	$targets{$_}++ for (keys %{$rules{last_minus}}) ;
	}

PrintDebug DumpTree \%targets, "added rules: $added_rule", DISPLAY_ADDRESS => 0 if $show_rules ;
}

