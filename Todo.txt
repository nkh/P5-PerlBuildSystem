write the generate file in cmake in pbs
	all the examples, including generation of subpbs and super build

	#can evaluate shell command be used as a templating function
		barely but it now renders references via DTD

	comment that there is no use to re-generate anything

#Do we need to have TARGET path set?
	it has it's uses specially when showing dependencies with -dd

pbs completion via pbs to be always up to date
	? too slow
	
put new Pbsfiles/... in MANIFEST

move rule_order tests to t/

Single rule builder doesn't work in -j

i:h isfname , ^wF, gF

--nh, display compact dependency information
	uses \K
	anything the prints while in -nh gets on the wrong line

can a node be tagged as source in another repo
	case 1
		add a node that doesn't exists
		node has subpbs
		subpbs has other rules for source
	case2 
		node exists but is not depended
		late depend tag node as source

touch pbs output files so they list in the right order
	many are in the same second!

bug trigger, in makefile releaser example trigger '.', build sequence hangs waitng for someting to be build
	? the trigger removes/adds too many nodes
	? source nodes linked multiple time

--bni not working
	what does it do except showing command before expansion?
		ndpb is the one stopping node info to be shown

?bug: warp doesn't care about variables, just node digests
	definition on command line is ignore
		that can be added to the pbs dependencies
			it would trigger the whole depend again
			but we'd like it to act on the few nodes that are dependent
				can be added as a node dependency

	definitions that are dynamic, compiler version, are ignored
		compiler versions should be compiler file
	
	anything saved in package data or not serialized is lost


md5 stats doesn't work as checks are in sub processes 
	merge stats
	=> should let the rendering plugins do the merging
		simplest for visualization but not for queries where one wants data to be together
			queries either merge themselves or we make a function available that does that
	
build regex
	allows us to point at nodes to be build
		the problem is that parallel build takes any node in any order, making it difficult
		to debug a specific node manually or look at what's generated before it is build

broken in vi with color
	first time goes to the file but not the line
	second time refuses to go to c:_objects ... even if the cursor is on the file name

	Matching rule: #1[B] 'c_objects:/home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/PBSLib/Rules/C.pm:48'

warp 1.8 pbs chain merge
	linking during non warp depend must also update the pbsfile chain 

ddr
	rule matching PBS_WARP_TREE is not shown

use tmux to keep session open when an error happens
	that would mean build in tmux
		or rebuild only the failed build in tmux

on error generate a script that
	sets up a tmux environment
	cat the build buffers as if one was building in the session
	add commands to history
	runs set of commands to ease debugging
		display debugging information

	run ranger 

move NodeInformation to methods
	many information elements are generated and added to the log or output
		putting the computation of the information in methods allows post processing to generate the same output

Fix all examples in pbsfiles
	make run
	document
	remove

Roadmap 
	*  is for next version, either not possible in current architecture or too little win for the effort
	+  high prio
	!  don't
	-> some work done
	#  done
	?  still needs thinking (basic thinking, not details)

	Warp
		*Meso warp

		load/regeneration 
			faster
				-> smaller size (15 MB for 12_000 nodes)
				less data
				on demand regeneration
					we regenerate the nodes but very few are reused in non warp run
					how long does the regeneration take?
		distribution

	Depend
		rule caching
			between pbs runs
			between packages

		parallel rule running		
			
		distribution and parallelization

		# linking configuration check
			move linking code to separate package and call
			user definable plugin to do the check 

		*rethink package dependencies
			simpler when config are rules matching nodes

	check
		distribution and #parallelization
		
		*separate check hash, generate build sequence, create parent information
		
		#by the time we get to check we have an inserted nodes list so we can check all the nodes md5 in parallel
			but when a node triggers it's parent nodes do not need md5 checking 
				we check nodes from the root down returning the build sequence
					do we need the build sequence when building in parallel?
						no but it is used in the current implementation
				we should check from the terminal nodes up
				
				the node level is known when it is inserted (parent + 1)
				parents can be known to nodes (not logical but for speed up purpose)

			that's the way warp does parallel check!
				one level at the time and main process triggers parents
				but the parents must be known to be triggered

		for distribution we need to synchronize common nodes
			synchronize with master for each node added to process local tree

			do a full depend and post process the graph to merge them
				we need to handle configuration as well as dependencies

				an added advantage is the possibility to query remote build nodes for sub graphs
					kind of meso warp for a sub graph but on another build node

					if a remote node has a matching sub graph, it can start checking and building it as soon
						as the graph has been verified

				handling of sub graph mismatch
					report error if no sub graph matched
						do we try to build the sub graph locally? yes

					report warning if some sub graphs didn't match
	build
		* distribute 
			distributing builds is easy, distributing sub graphs is more fun

		* generate meso data for nodes/pbsfile/packages

		light weight build node (just run commands know nothing about context)
			gearman
			? docker fs context
			lihtWeightServer was removed from pbs code

	Watch server
		make robust using lib or other external server
		? we need a distributed file watcher or one that cooperates with other
			they may be on different nodes with different type of watchers

		? VCS as watcher, fast enough

	graph generation
		* variants in the same graph

		remove local nodes 

	debugger
		interface
			rocky bernstein

		breakpoint
			*variable access or modification
				Config::Hierarchical has functionality

			grep output
				# can be done today by using a breakpoint

		query interface
			database 
			csv  + text to db 

	Repository
		?expand --source_directory to accept external binary repos
			match a "repo" with a query mechanism
			pbs doesn't care where it's coming from if it's made available locally
				we should still make the verification remotely, no need to compute a digest
				if it is available somewhere else
				
		?make difference between source and binary repositories 

	General
		PBS 2.0
			more implementation
			work on the requirements

		#Zero ENV

		+rename pbs switches

		#rename/alias ExcludeFromDigestGeneration
			use REH_SOURCE in pbs2 so a matching rule makes a node a source

			so we replace SourcesMatch with rules, expensive but easier tot see when a rule was made a node
			
			rules that only manipulate the node without adding dependencies or building it could be considered
			"meta data" rules and we could display them in a special way


move package dependent digest data to runtime package
	rather than in Digest.pm
		GetPackageDigest($package)
		$package::GetDigest()


	when applying rules, apply rule_package_dependency which adds node or package dependency to the node directly
		store in __PACKAGE_DEPENDENCY

		makes sense to have the dependencies directly in the node
		simplifies warp generation

binary repository
	client
	
	server
		? replace  --source_directory for binaries

		homebrew
			http server vs adhoc
			forking?
			crawls output directories, links to them
			
			


		the shiny with a web page
			plugin to do the mangling
				run as proxy server or within pbs

	local cache
	precognito mode
		knows about things that are being build
		blocking / asynchronous

	spreading the word
		synch with other repos
		address book

	administrative work
		backups
		removal of old objects
			

+Add to docs:
	PBSFILE_CONTENTS is added as a variable dependency, those are not checked in warp
		OK if the content is generated in pbsfiles
		if the content is based on an external file, that file must be added in the dependencies
			it's the responsibility of the user, pbs has no idea where it comes from

remove creator and PBS_FORCE_ type (only used by creators)
	can probably be replaced by a mechanism like the new C depender

do not put all the big files in the same sub processes (duh!)
	checking the size of all the node may cost more than checking them in the same process
	randomize and have more checking processes

log:
	#--log_node_pbs_data, adds pbs data to log, save time and space

	rules triggering are not in the log
	pbsfile loading is not in the log

	--log_html
		generate a set of pages from the log files
		navigation link on node names
		bread crumbs to parents


		or a simple page wth minimum javascript that uses dependency data
			need an out directory and a start node
			and a dependency graph, parseable, where does it come from?
				generate is in the LOG directory
				maybe we do not need a full graph, we can use the node's data

				given that they are in the same out directory, the data needs
				only list parents and dependencies and their build name to find
				the logs, 

				can start a browser anywhere, practical when debugging, looking
				at log data one can simply "click" the node.html to start browsing
				the graph
					this means that the script is in every html file!
				
	No need to have dependencies in the list, they are in the node info
		we need -ni to generate the link for us or parse the output

AddEnvVariableDependency in --j 0+
	passes 	passes in warp 0 

	=> warp does not support ENV, the warpified tree has no idea of ENV or anything that is not a file MD5
		Meso Warp will handle it!

	#? how does it pass the automated tests!n warp > 0 ? 
		test is skipped

working on JOB = 1
	automatic test pass when run by hand
		
	15% overhead for -j 1, probably much less for processes that actually does something more than compile 3 lines of code
		returning output and logs
		finding the node linearly
		handling the communication, splitting answers on tags

Node@root: time to retire
	doesn't play well with progressbar (but it's the crappy progress bar that should be replaced with
		something much simpler)
	loads all the warp files, even in warp
		doesn't have a config

	either do it with warp, saving the configs or build locally after saving the configs
		always save the config?
		
	

#new C depender, what if the compiler generates the dependencies but post build commands are not run?
	=> we need the post pbs because the build is in another process and the warp is in the main process
		meso warp fixes the problem without post pbs build commands but still needs to be
		stiched up correctly when meso warp master generation fails (or is not run)

	add: new c_depender test
		current tests cover the change


	#extra out directory
	#takes an extra run to stabilize warp, fixed


fork fails in windows, again!

Tie::Hash::Index pulls in a zillion modules and libffi
	
check simplified dependencies rules and perl rules
Check pbsfiles/config project

document EvalShellCommand and the order they are run as well as --evaluate_shell_command_verbose 
	that they are best put under lib/rules
	plugins are for global changes

c depender:
                $config->{'C_DEPENDER_SYSTEM_INCLUDES'},

	#option to not take in the system includes
	option to make the system includes a sub group so they are not displayed all the time in -tno

-bi does not work with -j
	shows info but build fails although it should continue
		probably node builder knows about --bi but not parallel builder

add --tmux-error option to test, with limit on how many are opened


\r \e[K

example of output with options on
	pbs -ho -o1 -o2
	pbs -warp 1.8  --display_warp_checked_nodes --display_warp_checked_nodes_fail_only --display_warp_removed_nodes

	searches for examples with all switches
	displays one or more examples 


AddNodeFileDependency
	the dependency must exist or it's MD5 can't be computed
	=> should wait till the depending node is build to compute dependent md5


	!!! why wouldn't we just add a rule? why does the file dependency have to be in the digest but not in the graph?
	
	not supported in warp
	=> Remove

	this is the mechanism we use to add dependency on pbsfiles, it can hardly be removed :)
		pbs2 put pbsfile dependencies in the graph, on another layer

	it is accessible to the user if they want to "use" non pbs files to define config or rules
		and want the dependency to be right

AddVariableDependency
	=> should be done in the rule, not globally in the pbsfile
	=> should automatically add the variables that are used during the build of the node
		%PBS_REPO would force all nodes to rebuild on a change of repo or added repo,
		which is the opposite of the intended purpose of repositories!
	
	Warp doesn't check variables! it works because pbs checks the pbsfiles where the variables
	are declared

AddEnvVariableDependency
	breaks warp
	env is evil
	=> put in config, add config variable dependency for lesser evil
		will still break warp
		overrides will be caught
		will be saved in config

project generation script can generate project which doesn't require compilation
	- we can still use .c file but
		- replace the .o depender
		- build the .o by touching them
			
debug breakpoint could display an informative message about what it is doing
and what is available for poking

install pbs on linux and pbs.pl on windows

Add a bunch of test with bad pbsfiles to catch syntax errors

# ---------------------------------------------- below is done ---------------------------------------------------

#pbs completion script to two streams or give root name for files

#?bug, if node can't be read for digest generation, the has is set to "invalid md5", when we re-run pbs
	we get the same digest and think it's the same thus nothing needs to be buid!
	this happens when node say they are generated but are not and VIRTUAL is not set

#Check.pm
	display all nodes that are not subpbs depended but are inserted in a different
	package than the inserting one

	display_nodes_depended_in_different_package

#reduce Pbsfile name in display

# DISPLAY_COMPACT_DEPEND_INFORMATION
	is it needed?

#cleanup modo example and add to distribution

#warn when many nodes are added in the same pbsfile

#keep dependencies in rule insertion order
	we now take them from the tree which is a hash
	but depend  non matches first

#bug! number of nodes displayed by "depend done" is not the same a s the nodes in the graph

	not efficient to run so many rules (at least till we scope the rules)
	probably a large pbsfile with many unrelated nodes

#infinite loop rules
	we catch self referential rules but not infinite loops

	rule 21, [ '*/2' => 'xxx/2'  ] ;

	or worse

	rule 21, [ '*/2' => 'xxx/3'  ] ;
	rule 22, [ '*/3' => 'yyy/2'  ] ;

	we can place a soft limit on
		how many rules can match
		how many times a rule can match
		how many nodes can be added

	# it would be nice to see the recursion and display it
		rule #1 -> node -> rule -> node - rule #1 again
			when the recusion is detected,we can crawl back the dependency graph till we find the
			parent node that matched the same rule, nice but seldom useful, a quick look in the
			pbsfile is often enough

		in sub CreateDependencyTree
			pass the chain of rules applied (hash) to recursive call
			pop when back from call
			if rule is recusive and soft limit passed, warn, then stop on hard limit
			

#replace all warn with PrintWarning

# add pbs distribution to the dependencies
	create a single file that contains the hash of the distribution
	include that file so the distribution is not listed in every single node digest
	also add the digest of the included file

	warp also needs to check distribution

# warp 0 doesn't save triggers
	other warp save the check log but w 0 doesn't have it it run's pbs directly

#display list of built nodes
	save them with the trigger
	
#why does Rules::Builders @120 add a node sub for shell generator?
	=> rule added an entry in the node when it matched
		this was used to
			display if the node uses a perl sub builder, determination replaced by simple system
			to save the commands for a lightWeightServer, removed LightWeightServer

#add an option that less verbose than ndpb -> ndpbm
	node name
	builder
	and a list what options to use to get more data
		put all the option under display_node_info_xxx


#display each command's result not just the last one

#changing a h file gives message
	h file only found in old digest
		not very friendly

#when using virtual file show errors in the virtual file not the pbsfile file on disk
add line number to generated rule ordering pbsfile

#time to completion example
	when digest can't be generated we only get a warning
	warp say ok althoug digests can be read!

#fzf option 
#Build.PL
	missing pbsfiles in distro?
	add new files in distro ... releaser


	Build: command: mkdir -p /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/xxx
	Build: command: cp -r /home/nadim/nadim/devel/divers/div_make/releaser/resources/css /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/xxx/css

	Build: './OEM1/xxx/css': build result: 1, message:


#Dependent in node build log for nodes at the bottom of the graph can be:
	very large
	take time to generate ( how is the 800 nodes generation time after we speedup this?)
		=> 0.8s to 0.5s

	difficult to read because we have the dependents + its node log link

	This goes in the build log too, it slows all the builds not only the pre build log

	bug: doesn't seem to be sorted properly

	    Dependents:
	    |- ./OEM1/aaa/css: rule: 4:csss
	    |  |- node info: /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/aaa/css.pbs_log
	    |  `- ./OEM1/aaa/encrypted.mol: rule: 2:mols
	    |     |- node info:
	    |     |  /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/aaa/encrypted.mol.pbs_log
	    |     `- ./release: rule: 1:release
	    |        `- node info: /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/release.pbs_log
	    |- ./OEM2/aaa/css: rule: 4:csss
	    |  |- node info: /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM2/aaa/css.pbs_log
	    |  `- ./OEM2/aaa/encrypted.mol: rule: 2:mols
	    |     |- node info:
	    |     |  /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM2/aaa/encrypted.mol.pbs_log
	    |     `- ./release: rule: 1:release
	    |- ./OEM1/xxx/css: rule: 4:csss
	    |  |- node info: /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/xxx/css.pbs_log
	    |  `- ./OEM1/xxx/encrypted.mol: rule: 2:mols
	    |     |- node info:
	    |     |  /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM1/xxx/encrypted.mol.pbs_log
	    |     `- ./release: rule: 1:release
	    `- ./OEM2/xxx/css: rule: 4:csss
	       |- node info: /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM2/xxx/css.pbs_log
	       `- ./OEM2/xxx/encrypted.mol: rule: 2:mols
		  |- node info:
		  |  /home/nadim/nadim/devel/divers/div_make/releaser/_out_nadim/OEM2/xxx/encrypted.mol.pbs_log
		  `- ./release: rule: 1:release

	=> not much to do, if we want it in the log we need to pay for the generation time
		- opt it out
		- speedup the generation
		- cache the generation

#display used/unused rules
	per pbs run
		display rule statistics
		display rules not run only


!display used/unused configuration variables
	pbs 2.0 maybe

--nh, display compact dependency information
#% path in shell command for file to build and any attribute
	%FILE_TO_BUILD_PATH1
	%ATTRIBUTE_PATH, PATH1, ...

#auto mkdir FILE_TO_BUILD_DIR

#pt not depended (OK) but no warning about resource/css!
	pbs 1 - 0 nadim!

#Linking ... "trigger inserted" ?
	bsfile:19, dependent: ./OEM2/aaa/css
	    './OEM2/xxx/encrypted.mol'
		'./OEM2/xxx/css'
		'./semla/OEM2/pt'
		2:mols:/home/nadim/nadim/devel/repositories/perl_modules/P5-PerlBuildSystem/Pbsfiles/releaser/pbsfile:12  [B][S] [1]
	    Depend: Linking './semla/OEM2/pt'[trigger inserted],


	global statistics
		filter output?

!display used/unused configuration variables
	pbs 2.0 maybe

#% path in shell command for file to build and any attribute
	%FILE_TO_BUILD_PATH1
	%ATTRIBUTE_PATH, PATH1, ...

#auto mkdir FILE_TO_BUILD_DIR

#pt not depended (OK) but no warning about resource/css!
	pbs 1 - 0 nadim!

#Linking ... "trigger inserted" ?
	bsfile:19, dependent: ./OEM2/aaa/css
	    './OEM2/xxx/encrypted.mol'
		'./OEM2/xxx/css'
		'./semla/OEM2/pt'
		2:mols:/home/nadim/nadim/devel/repositories/perl_modules/P5-PerlBuildSystem/Pbsfiles/releaser/pbsfile:12  [B][S] [1]
	    Depend: Linking './semla/OEM2/pt'[trigger inserted],


#dependencies are not ordered yet sometime we want to depend on the tool that will be used to build the node
	make has $< for the first dependency

	we can work around it with Shell Eval but it's still not very simple
		pbs2 has named dependencies

		can we use node attributes?
			rule n => a:attr dep dep
				%ATTR:attr
			
#log removal of environment variables
	log the kept variables too

# EvaluateshellCommand option to show before and after eval if changed

#USE and Config

#missing commit sha in version number

#tag node subs so we can list build commands without array ref
	? put the node sub in an array ref?


	Rule ......
		[
		builder
		builder_sub
		builder
		]
		node_sub

	Rule ......
		builder
		builder_sub
		builder
		[node_sub]

	Rule ......
		builder
		builder_sub
		builder



#mark tree nodes if they are virtual

#make all pbs artifact hidden
	log
	digest
	dependencies

#do not display the same source multiple time
	Build: removed nodes from sequence (source or build already done):
	    ./resources/css
	    ./repo/OEM1/pt
	    ./resources/css
	    ./repo/OEM2/pt
	    ./resources/css
	    ./repo/OEM2/pt
	    ./resources/css
	    ./repo/OEM1/pt


#Source, is source, ...
	sugar to declare source files
	=> NoDigest

#AddDependencies a simple_r_ dependency generator which wraps a full blown Depender
	the idea is to not have to care for previous dependencies, private data, ...
	those can be handled in a complete depender

		AddRule 'mols', [ qr/encrypted.mol$/ => , AddDependencies { './' . (split('/',$_[0]))[1] . "/pt" },  $path/css'],

	also check that it's possible to have dependencies _after_ a depender sub


#colors
	slightly brighter error color
	night time colors
		simply another color set, we can chose those right
		ENV variable? lol!
		
		pbs lib that when loaded changes the colors depending on the time of day and option


#warp 1.5 size
	_LOCATION field
		it's repeated for each node but often we have 2 different location
		indexing the _LOCATTION can speedup loading of the file and reduce memory footprint 
			in a test _LOCATION:some location took 70 KB space for a 1300 KB warp file
				we still need _LOCATION:index so it will still take some space

				we could use a shorter variable too
		=> when --human is not use we should use shorter variable automatically, for all variables
			a script can generate a human readable log from the compact one

	#--warp_human_format
		save a more compact format by default and use this option for something readable

#node log dependencies (dependencies named in the node's log)
	are listed without link to file
	triggered nodes have the needed information

		Dependencies:
			./1.o:__DIGEST_TRIGGERED,...(2)
			nodeinfo:/home/nadim/no_backup/pbs_tests/generated_pbs_project/_out_nadim/1.o.pbs_info
		Matchingrule:#9[B]'1.objects:/home/nadim/no_backup/pbs_tests/generated_pbs_project/pbsfile:77'
			=>./1.o./2.o./3.o./4.o./5.o./6.o./pbsfile_2/7.objects

	=> shown when they trigger

#info-label ?
	#check ---dpbX and other print using escape codes
	#add in node logs
	#node output gets two label on error

!logging
	we log which node have triggered in the _warp directory
	log which files have been removed from the graph
	log which files are build

	all this could be extracted from full log instead for being generated by pbs

#bug:
	Warp: Removing  /home/nadim/perl5/lib/perl5/PBS/PBSLib/Rules/Object_rules_utils.pm [modified]

	#1 this is checked way after normal nodes are checked
		gloabal dependencies, pbs libs, should be checked first

	#2 build proceeds, warp is generated, hash is not replaced with new value!
		There's no hash at all!

	need to rebuild? broken cache

	=> checked for node re-warped in node index but the node_index is rebuild from the old node!
		check in re-warped nodes instead

#depend not indented

#error Depend: pbsfile: 1, time: 1.28 s.
	wrong number of pbsfiles

#find out if LOCKCONFIG is merged from neo project
	yes, if(defined $sub_pbs_hash->{PACKAGE_CONFIG_NO_INHERITANCE} || $pbs_config->{NO_CONFIG_INHERITANCE})

#no_color if redirected?
	we have no output to stout, only stderr
	
#what's the switch to have no progress bar and only the node header?
	-ndpb seems to switch -bni on 
	=> checked if variable was defined instead for value
 
#--tno should always be displayed as --tnt

#--tno
	shows all the nodes
	shows the PBS libraries as dependencies (which is right but boring)
		when loading graph from warp file
	stopped displaying __WARP_NODEs except those linked in the new nodes

	this also stopped the display of the library nodes, because those are warp nodes
	but not linked to by the new nodes, the linking to the library nodes is not done during
	depend (which it should) but during the warp phase

#in log for object file
	a dependency is missing and and an info file is pointing to a location that does not exist

	dependencies:
		node info: /home/nadim/no_backup/pbs_tests/generated_pbs_project/_out_nadim/pbsfile_2/pbsfile_9/pbsfile_10/pbsfile_11/pbsfile_12/pbsfile_13/73.o.trigger_dependencies.pbs_info
		__SELF: : not found on disk

# pruning shows the same node multiple time
	checkers are run in parallel

#--trigger -fb
	nodes loaded from warp trigger even if --trigger is not given in the run!

#--trigger ., triggers .o.trigger_dependencies
		that stops the build!

		-bi . makes it go forward
		PARENTS is not set for .o.trigger_dependencies, stopping the queueing of parents in the build list


#error?
	need to re build multiple time for warp to stabilize
		warp digest not updated (due to node index?)
		
	--check only terminals may also have the same problem as above

#node log file point to info files
	#info files are generated during depend
	#log_info not removed when logs are created
	#log doesn't contain link to parent logs

#log doesn't contain build command expanded

#source code node info
	generated in the source directory
	why?!

#in warp, pbschain{LEVEL} is wrong
	the same pbsfile can be used at multiple levels we can't simply overwrite the value

#warp file contains lib with line number!
	├─ 21 = '/home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/PBSLib/Rules/C_depender.pm':149  [S22]
	happens after build, pre-build warp has the right nodes
	=> C_depender set file with quotes and file number

#warp dependencies are not regenerated for pbsfiles not part of the build

#warp fails with too few nodes back in the warp file

#Rule C_object defines a node sub, WHERE?
	=> all rules having a shell command(s) have __SHELL_COMMAND_GENERATOR set via node subs

# --lni can be done in parallel

#move 2.h 2.hh didn't rebuild!
	=> 2.h is not in the warp file!
	post build commands are run in the build process we can't set __PBS_POST_BUILD there
		use a node_sub, which is ran during the depend phase

#failed build doesn't keep the log (but is displayed on the screen!
	=> successful build didn't fetch the log (log is kept), failed builds fetch the log and keep the log only if --log was specified
	=> always keep the log which is generated anyway

#after a failed build generating node info files generate these warnings
	Use of uninitialized value in concatenation (.) or string at /home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/Information.pm line 266.
	Use of uninitialized value $package in hash element at /home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/Digest.pm line 640.
	Use of uninitialized value $package in hash element at /home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/Digest.pm line 656.
	Use of uninitialized value $package in hash element at /home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/Digest.pm line 640.
	Use of uninitialized value $package in hash element at /home/nadim/perl5/perlbrew/perls/perl-5.28.1/lib/site_perl/5.28.1/PBS/Digest.pm line 656.
	=> we use IsDigestToBeGenerated which needs a package which doesn't exist in warp except for rebuild packages


#changing Rules/C.pm makes warp trigger indefinitely
	? nothing to build, warp not regenerated!
		the C.pm serialization in the warp file differs after C.pm is changed
	
	=> after warp is loaded we used the names index from the old warp to check if the node was serialized
		the error was that triggering nodes where not removed from the index so warp used the old lib serialisation

#use Term::Emit for message, maybe replace Term::ProgressBar too
	=> replace with simpler code not in a module, we already have a %done for forked builders

#log build command
	so it can be run from vi, in terminal

#log file is generated even if no -l is given
	maybe we should always keep it 

#--log
	log the build results per node and the location of the node log


#-lni file is put in the source directory
	should only be generated for non source nodes

#put -ni output in log file
#separate node info generation when no log info is needed
	log information takes a longtime to generate and is used for --lni only
	should -l output everything too or the same as before


#Generate a log (like the build buffer) for nodes not build yet
	when a node fails, we may want to look at the dependents and their configs
	see pbs2 ideas
	=> ni shows the non warp files

#write tree data to log file takes some time, even when a single node is being rebuild (with warp)

#--display_md5_warning to control
	Digest: Warning: can't read file '/home/nadim/nadim/devel/divers/div_make/_out_

#multiple plugin and lib path

#display what's being build in a short dynamic tree form
	to avoid the guessing when, ie, working with Robin

	=> ridiculous idea!

	wait!
		we have a graph, we know what nodes are being build or are completely build
		what we don't know is which nodes are interesting
			some build systems treat nodes after their types (euurk), ie: executable

			we need a mechanism to remove nodes from the graph display (short form)
				do we love regexes or subs ?!
				less attributes but it's OK to write a node sub (if I remember how to)


		create a new graph, which ignore unimportant nodes
			or maybe filter the whole graph

		graph must be less than a page to be of any use

		update state when nodes are updated
			just a few states are interesting
				nothing being done
				dependencies being built (is %tage of interest?)
				node is build
			
		update fast enough
			which means no traversal when nodes are build
				callback?
			most difficult is dependencies being built and %tage
				the important node can update itself when build		

	=> still ridiculous!
		who cares what's being build?!

		if a specific part is of particular interest just build that one till it works then the whole system

		of interest:
			what's been built if the build failed
				and not really sure it's of any interest really
				
				we need a list of what's been build
					filtered
					colored
					displayed hierarchically 
					
					=> perfect job for a post pbs, custom written 
	
			what the failed node build is part of (--np fixes that part)

			some color on some nodes in all output
				pbs ... 2>&1 | h whatnot # quick fix, more than good enough

			Have some node flash information about their build state
				!post node build
					=> a tad late

				break point
					pbs -ke . --trigger 246 -fb --debug ./bp  -ndpb -bnir 'xxxx'

				added to the builder directly
					pbs2 rule injection would work nicely here




#Box shell command option

	some build commands generate a lot of output, IE: running make, make the output more manageable by

		optiond format: --box_output_type			 
			
		!indent the output
			indent, increment $pbs_indent 

		!box the output
			that adds too much noise, indentation and color are less intrusive

		color the output of each command separately
			change background color
				light shade of grey (color in colordefinitions.pm)
					successive commands in different shades of grey

				light shade of another color

			
			#handle commands that use color themselves
			
			!color the indentation only

		!keep a build buffer per command rather than node
	
		shorten output and add link to the output (editor or web page)
			sets --keep_build_buffer and displays build buffer name

	#apply per package, node, globally
		via a regex for Pbs
		via REH for Pbs2

		!--box_output regex (which node to box)

	#--silent_command and --silent_command_output take regexes
		add --verbose_command and --verbose_command_output
		=> --bnir

#make -bni standard even when displaying a progress bar

#!error not added to the build buffer


#node@root not build
	but .dependencies corresponding to .o is

	rm -rf _out_nadim/ ; pbs -ndpb ./pbsfile_2/pbsfile_4/pbsfile_5/25.o@./objects --no_pbs_response_file --display_build_sequence_simple -fb

#output of next command seen in previous command
	second command in array in test2 example

#build display types
	#display of build nodes
		build.o
		build.o
		...
		info (process, nodes,...) [progress bar]	

	!display of build nodes
		[high level action]:[sub actions] 

			next sub actions doesn't create a new line, new lines appear only when a new high level action is executed

		eg:

		building library "some lib 1": compiling "some source", "some source 2", ...
		building library "some lib 2": compiling "some source"
		linking "some app": ...
		generating documentation: ...

		=> PBS2, REH_BUILD_DISPLAY(xxx) for specific high level nodes

	#display of build nodes
		[information ...] 
		[build process 1]:[actions] 
		[build process 2]:[actions] 
		[build process 3]:[actions] 

#fix error in build process dies on split! 
	Forked line 551, Pbsfiles/hello_fail
 
#Fix cyclic pbsfile test
	COLOR get an undefined variable to display
	cycles displayed twice
	unhandled type REGEX
	at home/ndim ..../ module.pm

#more colors
	rgb/256

#write everything to stderr

#more check optimization
	do not put all the big files in the same sub processes (duh!)

	all source files are terminal, doesn't matter at what depth they are
		we check files per level, to avid checking something that would 
		be triggered at a lower level

		this is not the most efficient as two large terminal files at different
		levels would be handled sequentially!

		check all the terminal nodes together only
		remove them from the nodes to check
		remove all they triggered dependents
		check all levels
			checking all levels and not only terminals is for the case
			where a terminal is not modified but a generate node is

			! a heavy price paid to correctness

			we still need to compute md5 for regenerated nodes but only them



#--ndpb
	-ni is active although only headers should be displayed

#no output from parallel check
	# too quick to see anything of interest but looks frozen on big chuncks


#Is md5 recomputed for elements of triggered nodes?
	in big test
		objects was made dependent on a mkv
		objects is triggered
		when building it, there is a delay, which does not exist when mkv is not a dependency


		extra md5 in pbs?

		objects format builder??
			=> uses the md5 cache

		=> -ndpb -display_md5_time is your friend

	dependent is rebuild, pbsfiles arre loaded, new nodes created
		warp removes dependencies, removed digest cache?

	=> parallel checking doesn't share cache!
		when we start building all md5 must be recomputed in the main process, even source

	Cache synch added 

	this is a worst case scenario, one huge file and a bunch of small files
		the small files are processed quickly and we block on the huge file
		till we can get onto the next level

		worse case scenario is i all the large files are in the same sub process to check
			=> that can be dealt with when slicing the nodes to check but is an extra check


#./objects [V] couldn't be triggered with --trigger
	=> --display_trigger
	=> can't trigger a virtual, it's the whole idea that dependencies trigger it

#running pbs post build commands takes time, why?
	=> warp regeneration takes time not post build commands
		Not because cache is empty, --display_md5_time shows only few digests are computed
			generating the 2 Mb file takes time

#left flushmd5cache

#3.o, where'd the digest?! in warp :P

#new C depender has dependencies rooted in / even when dependencies are in ./
	makes long lines of display!

	same problem as before, can't move the project without rebuilding all because
	of system dependencies


#Keep builder in non parallel builds
	#keep non failing output too
		all builds parallel

#--trigger
	#--trigger_none --trigger_list
	#--trigger no stop as DEBUG_FLAG
	#make it work with warp > 0

#--tt takes a node name, make it a regex


#pbs files locations
	PBS_LOGS   -> _PBS_LOGS
	warp 1.8   -> _PBS_WARP_1.8
	out_nadim  -> _PBS_build_dir_nadim

	or all under a main directory
		_PBS
			LOGS
			WARP_1.8
			build_dir_nadim		

#log name with date!

#sub logs in sub dirs? with build buffers?

#catch die in sub process
	already done

#log creation doesn't work with -j
	need a composite log, which is a good idea even without -j


#big  -j 8 needs 3 builds to stabilize
	-j 12 goes through!

	parallelizer checks that all nodes in the build sequence are build and reports error


#error: gcc failure when -j appears before report by pbs. stderr not redirected?
	in case that would be buffering, this code may help use IO::Handle; STDERR->autoflush(1);

	fixwd but redirection kills coloring of gcc output


#running post pbs commands even when not runnning the build
	must run even if some build failed but not if no build at all


#gtg, why different config objects, => we would have a completely unreadable graph, local config is closer

#self or sub dependency

#in all warp files
	local $PBS::Output::indentation_depth = -1 ;
		calls PBS::PBS::Pbs which increments it immediately 

	problem is after the call to PBS::PBS::Pbs, we call other functions and we have -1 in the variable
	
#--files, ... 
	pbs --no_warp --no_build --nodes -no_color | grep '^node:' | cut -d ' ' -f 2 | for i in $(cat); do  echo .${i##*.} ; done | sort -u

#Generate SVG by default

# Sort node in tt by insertion time

#ORIGINAL_INSERTION_DATA on first run , invhouse?
	# warp doesn't have that information

#add $file_no_ext, with a better name

#in modo #1 config is different, why
	keys not sorted before hashing

#test write data in test_cmdXXX.XX which is really not helpful
	put everything in a sub directory named after date
	put tests in warp type subdirectories
	name test directories after test names
	prepend FAILED to test directory  on failure

#if not tagets are given, try to extract help from the pbsfile

#build buffer name should only be displayed if --keep_build_buffers is set

#add remove deepest node script to distribution (perl version)
#add default pbsfile in generated project
#add examples/scripts to run the various warp modes

#stdout/err redirection should be done through a standard module

#use Memoize to speedup Warp 1.8
	25% faster with memoize
	check:
		no warp 1.8 exists
		generation of the empty warp takes 2 seconds
		after verifying the tree, second warp generation takes 1.5 seconds
		this is strange as there is nothing to build, I expected an
			almost instantaneous warp generation
		next run, with a node to rebuild, generation is 0.2 seconds
		
#"no user defined builder, using namespace xxxx" should not be displayed by default
	using namespace and config should be displayed when a non default config is used

It should be possible to display a package config before and after the Pbsfiles is run. 
	Displaying a delta only would be less cluter. 
		(not possible in current config module, overrides are pushed in parent config)
	Controlling the configuration dump should be possible
	displaying a nodes config delta in -bni
		=> means we should be able to extract the config from the node
		
node config should keep the package config and only store its config delta instead
	for making a copy of the parent config
	
? Rename AddConfig to SetConfig

PBS accepts cyclic dependencies in source files (IE c, h)
	this should work only if a swith is set instead for being default
	when the dependency is in C file cache, no warning is displayed when
		the cache is used (OK but let's spam the little buggers)
	
Plugin FileWatchClient has a peculiar way of finding out what a node __BUILD_NAME is
	=> define the nodes (passed as arguments) in a better way
	
warp and watch server: 
	in the event of a warp run with unexisting warp file, it is still possible to use the watch
	server if it has been used by another pbs run. of course this means the server keeps
	the md5 not only the fact that files where modified
	
	The md5 filesystem should keep the md5 in a cache
	
	Warp 0 should also use the watch server

Add tests for watch server
	warp file exists/not exists
	warp fails for a single file should not need to rebuild all (see remark in warp 1.8)
	
PBS + vanilla perl + PAR

Problem with triggers and fully located dependencies
	path/a => lib/x means the library _has_ to be located exactely there under the right path
	this was partialy fixed with path/a => ./lib/x but now all the libs must install under ./lib (which is not so bad)
	A run time search can also fix the problem but only if the lib was already inserted
	Also late depending might have an influence

how can the following be optimized?
	a => b; b => c; c => d; d => e;
	'pbs a' would run 20 rules while the minimum is 4
	
	=> it is possible to scope rules
	=> the scoping could be made automatically
	
	
#configuration variable are first store in pbs_config->{CLA} then added to the config
	this means that no warning can be generated if the same variable is defined 
	twice, in a different way, on the command line. This is also a problem with 
	loaded config wich is handled as a command line config. 
	
	A better system that warns of these assignments would be preferable
	

LOCAL variables are not reported as warnings when override a parent config!

sometimes we just need to know what component has to be rebuild, pbs can give
	us a list of files but doesn't understand the concept component. Can this
	be achieved?
	

watch server broken for generated projects !!?

#add --save_configs and --load_config

make serializing protocol independent, ie the caller shall not know what serializer is used

Split $inserted_nodes in parts (dry nodes and live nodes)
	=> there is no reason to go through all the nodes to find out which ones are live (warp 1.8)
	=> can be done by an object (same interface as hash + query members) or two variables
	
lint mode (might be possible to do in a post pbs)
	display which pbsused modules didn't have a matching rule
	modules without rules defined
	modules with too many rules defined
	modules that override configs
	
failed tests should automatically generate dump even when run in batch mode

warp
	make warp 1.7 default and fallback to 1,5 with warning if no DB installed
	merge warp modules
	#have unique -warp switch with arguments
	#make tests work with all warp mode (not dependent on output)
	how expensive is it to gnerate the warp file in multiple small files (one per node?/subpbs)
		=> implemented in W 1.8 and very expensive generation
	
Generate bash completion when building a distribution
	pbs might not be installed and thus must be taken from blib

some of the display_warp_* switches don't works

verify arguments to AdddRule and other front end functions
	=>ie rule without rule name dies mysteriously with error at line 349 in Rules.pm

^micro warp should allow us to run part of the build with warp and other parts without

#make dist should export the distribution tar ball to a web site and put it in svn (and update the information)
#add generation of _latest tar ball 

#svk is the one having problems in the install and tests

#do not generate version module if svk is not installed instead use the  one comming in the distribution

all output should go to a data structure and display should be done by plugins
	=> can we use DTD for the display, ie give -dtd a parent glyph
	output should be kep in nodes and in "pbs". the output should be kept on file

output plugin in linux boot style
	Dependinf subpbs    xyw                                               [OK]
           Depending subpbs    abc                                            [OK]
	Checking dependency tree                                              [OK]
	Creating build sequence                                               [OK]
	parallelizing build sequence                                          [OK]
	Compiling c_chdir.c:                                             [12%][OK]
	Compiling c_chdirlist.c:                                         [16%][OK]
	...
	
-tnd doesn't show more than 2 levels depth
Processed 3 Pbsfiles.
Tree for './world/world.c':
|- __ALTERNATE_SOURCE_DIRECTORY = /mnt/mirror/devel/perl_modules/PerlBuildSystem/Pbsfiles/hello2  [S1]
|- __BUILD_DONE = node was up to date  [S2]
|- __BUILD_NAME = /mnt/mirror/devel/perl_modules/PerlBuildSystem/Pbsfiles/hello2/world/world.c  [S3]
|- __CHECKED = 1  [S4]
|- __CONFIG  [H5]
|- __DEPENDED = 1  [S6]
|- __DEPENDED_AT = /mnt/mirror/devel/perl_modules/PerlBuildSystem/Pbsfiles/hello2/world/world.pl  [S7]
|- __DEPENDENCY_TO  [H8]
|- __DEPENDING_PBSFILE = 4fe63bb26549e4c3fa73da49d27c0702  [S9]
|- __FIXED_BUILD_NAME = /mnt/mirror/devel/perl_modules/PerlBuildSystem/Pbsfiles/hello2/world/world.c  [S10]
|- __HAS_DIGEST = 0  [S11]
|- __INSERTED_AT  [H12]
|- __LOAD_PACKAGE = PBS::Runs::world_world_o_world_world_pl_1  [S13]
|- __MATCHING_RULES  [A14]
|  `- 0  [H15]
|- __NAME = ./world/world.c  [S16]
|- __PACKAGE = world_world_o_world_world_pl  [S17]
`- __PBS_CONFIG  [H18]
   `- __RULE_NAME = world/world.o | ./world/world.pl  [S19]

#esc[A instead for \r
	=> needs a \n too which means that an extra blank line is displayed at the
	bottom of the terminaln a tad confusing
	
PBS2: make all the elements in a node typed to allow selective dumping and coloring (see DTD todo)
	=> should we also type the output tree so ze could also write filter for coloring and display
	
should it be possible to hint the parallel builder to NOT build some node in parallel?
	=> like build them first
	=> in which order?
	=> AddRule '', [xyz] => Builder, BuildGroup('name', priority_for_node) ;
	=> can build groups be virtual nodes

immediate build and parallel build, how does it work out?
	=> shouldn't have anything to do with each other as immediate build is done
	during 'depend' and 'depend' is not parallel (yet)

remove the DF flags and replace with a --no_build?
	=> problem is with skipped build during depend + immediate build

#when a C file is full path, the dependency file is put in that directory
	=> is there anything we can do?
		build an equivalent path under out_

Add script to checkin the project state before building (svk)

in PBS2 give the config switches the same name and case internaly and externaly
	=> make it easier to pass argument in a subpbs rule
	
Should it be possible to run local rules and subpbs rules?
	=> switch + warning?

Handle multiple plugin directories: takes Multiple directories but not manipulated right

Should all the nodes depend on all the loaded plugins?
	* difficult with sub ref plugins, we need a sub md5
	=> at least those changing the build like shell command evaluation plugins
	YES! all of them
	=> should also depend on pbs install
	
how do we handle nodes with lots of dependencies but we just want some of those
	dependencies to get into %DEPENDENCY_LIST
	=> node sub, extra function, rule registrated EvaluateCommandLine, ...
	=> named dependencies, later %DEPENDENCY_NAME
		[X => 'Y.c:name=>Y', Z.c] => '%commamd %DEPENDENCY_LIST -o %DEPENDENCY_Y'
		
	
think about a more flexible %something expansion in command lines
	=> pbsrun scope would be better than global scope
	=> rule scope is even better
	=> named dependency!

#immediate build should  handle -tno ... switches
	Add the following after checking the tree
	RunPluginSubs($pbs_config, 'PostDependAndCheck', $pbs_config, $tree, $inserted_nodes, \@build_sequence, $tree) ;

#switch to stop between rule runs or when a node is inserted
	=> on command line or through the debug interface?

#-nli doesn't work if no -dd ?

#Make AddSubpbsRule accept 4 or 2 arguments

#display_search_info is not used in Check

!when output is redirected, remove colors
	=>use no_colorization instead

#an extra -tt switch to show what rules inserted the nodes

#make -tnd work

#Why are dependency nodes merged?
	=> because there are no rules for them. Only the depender knows the relation between them
	? shouldn't we have rules instead
	
#update the switch in the documentation for --display_search info

!Rules that adds a subpbs rule at the same time:
	=> no because too much magic and we want to see the subpbs rule
	AddRule [VIRTUAL], 'all', [ 'all' => SubPbsDependency('QixApplication/qix.app')	]
		=> BuildOk();

	sub SubPbsDependency
	{
	my ($dependency) = @_ ;
	
	my ($package, $file_name, $line) = caller() ;
	my ($basename, $path, $ext) = File::Basename::fileparse($dependency, ('\..*')) ;
	
	
	AddSubpbsRule("$dependency @ $file_name, $line"  , $dependency , "$path/Pbsfile.pl" , "$dependency @ $file_name, $line") ; 
	
	return($dependency) ;
	}


#Add example of how to use Evaluate ShellCommandForNode in the Builder wizard

#Expand .objects in command line

#--version should display subversion too

#change -dd format to more verbose and easier to read

#sub NonCached_GetFileMD5 warning

#Make the output better for linked nodes:
	#=> 'Linked node was inserted ...' should be indented and first line after 'Linking existing ...'
	!=> it should also be possible to see a part of a tree
	#=> test with local matching rules
	

#make -c default and replace it with --no_color


AddConfigVariableDependency and AddVariable Dependency should be inlined with the rule
	=> AR [dependent => 'file', ..., VariableDependency('NAME' => 123), ConfigDependency('CFLAGS')]
		Builder("%XX ............ %NAME %CFLAGS")
	most build systems handle this by remembering the command line. This stops working when using
		source directories as the sources can come from different locations. It also doesn't work
		when the builder is a sub instead for a shell command. This also means that it should be
		trivial to call VariableDependency('NAME' => 123), ConfigDependency('CFLAGS') from a 
		sub builder to add the variable dependency to the node being build
		This in turn means that sub adding node dependency should be members of the node class

Automatically find or/and verify dependencies
	=> if a file is a dependency, it will be accesses when building it. It should be
	possible to verify which files are opened through inotify or bsd accounting 
	
when immediate build runs, it runs in the same warp!!!
	=> when an immediate build fails, the number of nodes in the warp tree is 0!
	=> should an immediate build have a separate warp, should they be merged afterwards?

Clean and merge this file, the wiki contents, RT and pbs2 requirements

#Document PBS/Watch/*.pm

#Current MultiNodeBuilder is more a SingleRunBuilder
	=> Change name

#MultiNodeBuilder should accept a shell commands

Add test for the watch server

Add script that runs a build with a watch server and randomly remove a file in the output directory
	=> make that internal to pbs (--random_remove_generated_nodes)
		=> display_list of removed files and also write it down in a log and make it available to post pbs
	
#-ndpb removes information from the statistics!!!
	=> -ndpb creates another warp file which is empty in the first run (lol)

--------------------------------------
under this line has __NOT__ been analysed and added to PBS2

Yet another warp idea!
	as of 0.40, the warp tree is completely loaded and checked, some nodes are
	removed and re-vivified. Warp 1.7 uses a db instead for a file but this is still the same principle.
	What warp does, is to verify which nodes need to be re-vivified. To do that only the node md5 is needed.
	The nodes md5 could be kept in a separate file/db which is fast to load. Once we have a list of nodes to
	re-vivify, we could generate the tree of re-vivified and triggered nodes only instead for regenerating 
	the whole tree, this is time and memory effective (might be a bit slower for full rebuild). The information
	needed to generate the triggered nodes tree is distributed in the re-vivified nodes "parent" field.
	the non re-vivified nodes still need to exist in $inserted_nodes but they do  NOT have to be real nodes but
	only placeholder to allow PBS to link to them (a shadow node, it's data being available in the warp db).
	
	What do we need the warp tree for?
		something to link to (which isn't necesserely a real node)
		a dependency graph
		
	=> we could implenent warp as:
		a list of files in the graph with their md5
		a list of dependencies per node
		
	when verifing the warp tree, first create inserted node with phony nodes, verify the md5,
	remove dependents for triggered nodes. Build, update the md5 in the db. No warpification needed!
		=> Wrong, if a c nodes dependencies change, the warp file MUST be regenerated
			there might be a less expensive solution; instead for regenerating the whole
			warp graph, a diff between the _current_ "live" tree and the "dry" tree can be done,
			if no nodes have been added or removed, no regeneration is needed, only an md5 update.
			if nodes are added or removed, only modify the nodes that have lost/gained a new dependency
			as well as adding removing the new/deleted nodes.
	
	If a dewarpification is needed for another pbs step (graph ...), do it only when needed or, better,
	eliminate that step.
	
	Warp 1.5 introduced an optimization which consisted of removing the nodes that we knew would trigger if
	a child node was to be rebuild; that allowed use to limit the amount of md5 to compute, that optimisation
	is still possible and wished for. Note that the optimization itself is not optimal as we should verify the 
	nodes with lots of dependents first.
	

	Important! the graph doesn't need to be regenerated. Shadow nodes are
	not necessary, the re-vivified nodes can be phantom and not link to
	the DB at all

	if a watch server is running; warp load can be totally removed.
	instead for verifying the nodes for changes, just keep the nodes that
	HAVE changed. when a node needs to be accessed check with the modified
	nodes and return  a phantom node if it wasn't modified.

	

Current MultiNodeBuilder doesn't verify that multiple nodes are build. this is not possible as PBS doesn't
	accept multiple dependents (might be a good idea for PBS2). PBS would then have to remember what nodes
	are to be build by that multiple node builder and guaranty that the nodes are build as well as generating
	their digest.


MultiNodeBuilder should accept a list of commands and shell commands
	maybe the builders should be "multi builders" but we should have multipe rules instead for a single rule matching multiple nodes

Emil: Precompiled headers are not used when building from vcproj files. Check q05a\build\PBS\PBSLib\Rules\cl_pch.pm.

Emil: swig builds too often
	A digest is generated but not synchronized before object files is built. If the object file is not built the creator checks a digest file and does not find it, thus generates the C file again.


Add tests for the new way to handle switches (removal of env variables)

DependAndBuild should populate the md5 cache

Watch server doesn't have to only be used by warp
	=> Watch server could also keep the md5 so they don't need to be computed for unmodified nodes

output format should use tree like glyphs

Try Data::Dump::Streamer to serialize sub

stop using closures

Use the Attributes.pm module or remove it 

plugins should be able to inject themselfs in PBS
 ie: the parallel build could be a plugin; it could take over the rest of the build or only parts
 or we could query the plugins to see if they can handle some tasks
 => this a good architectural change. pbs setup becomes a bit more complicated as we need to find and load the plugin
 switches first, load the plugins selected through their switches and replace parts of PBS. This is a good way
 to handle the different versions of warp. before loading plugins, we should give them the possibility to
 verify their setup is complete. IE Warp 1.7 needs a DB module to work properly.
 
!New pod documentation format
 see pbs.pl

name http://rake.rubyforge.org/ in PBS
	=> and in the web site too
	
#Remove all the environment flags
 force the creation of user.prf with the default values 
 the template for user.prf can be changed globaly
  /usr/lib/perl5/..../PBS/global.prf
 a per-user template can also be created and automatically copied
  ~/.pbs/user.prf

compute a warp signature and add it to the output directory name
 this would remove the need to say "pbs -D=debug -output_directory debug"
  we should find a way to make it look nice too , like asking for a name when a new warp signature is found
 use out_$USER as the default output_directory but write a signature in it
  if the signature for the current build is not the same, as for override or propose another directory
 => do we allow multiple warp files in the same output directory? do we instead propose to add a source_directory 
 to the command line (that is have a different build directory but still share the other build result)

it should be possible to generate an executable pbs with all the dependencies the project have so pbs and the project can be delivered together
	=> this is as simple as accepting a -sd PAR:/
	=> all file acces should be through an URL and default to the local file system if no base given
		=> this could allow us to generate file on the fly through a PERL://
	
makefile to pbs converter

Give target or node name and follow it from birth to build (generate document)
	=> generate this from the output/ dependency tree
	
Work on the optimizations made (commented out) in Check.pm

check why changing a comment in a C file doesn't generate the same binary

Can a run under warp add or remove nodes from the dependency graph?

Make warp share code

lint all module, pass them through the verification modules from CPAN

Warpify function is the one taking much time in warp generation
	optimize (XS?) or eliminate it
	optimization could be achieved by reducing node information and not warpify
		? keep warp info and other separated from the begining in the node
	should the nodes serialize themselves in a db instead for running from memory?
	if the nodes are written to a DB, the warp file generation is distributed through the PBS run
	   thus much shorter at warp file generation time
	
Make global $PBS::pbs_run_information part of a run object
	=> which should also contain the global caches we use
	=> think about threaded/forked context
	Keep stats:
		timing
			#warp 1.5
			warp 1.7
			build time and builders time
			pbs overhead
			#cache verification
			#watch server
			parallel builder
			number of processed pbsfile
			maximum depth (where)
			number of rules ran
			nodes scheduled for build
			md5 cache
			later, distributioninformation
			...
	=> where do we keep the stats, how do we differenciate them (name them)

start using and accepting URLs to file (prepare for distribution)
	this is also good for the warp server
	
when running -j and doing a lot of depending, forking occures
when the master process is big thus generating a lot of swap and eventually errors
	=> run the depend with one process, generate a warp file => stop and restart in -j mode
	
?? broken build in -j mode  (with lots of depending) => build
	=> run with warp 1.7 => found unsynched C chaches
	
Also keep stat on what warp was used and the size and generation type of warp files

Perl subs time: 1306.51 s. is wrong when using -j

-dcdi should have another option that doesn't show the file name but displays
	statististics about C depending on one or two line (use /r or curses)
		=> # file, # cached, #unsynchronised, #valid, time doing that
			=> above per package and total

C depender is too slow!
	make it faster
	ignore the depend step if the object file is going to be generated anyhow
		build and depend (not 'depend and build')
	can we glue this as a post build command or a node sub/attribute?
	
#time if gcc is faster at generating dependencies than cpp


#-j with deep hierarchy generated 'file too long error"


also generate statistics about memory and disk usage (out_xxx)

Deep recusion warning
	=> remove? rewrite? have own max depth?
	
Reduce memory usage (2 GB is too little with 50_000 nodes)
	=> reduce amount of data
	=> "Dry" parts of the graph during run time
		=> we need to remove cyclic dependencies, wouldn4t that remove the possibility to 
		dump the dependency tree with data tree dumper?
		=> use DB?
		=> keep all data (unlike warp) as some options need the data
		=> builder subs can stay in memory
			=> stop generating them before hand
	
project generator
	#CLI
	scriptable => module
	if all C files are identical, the builder could copy a pre-compiled binary
	 thus reducing compile time (which we don't really care for)
	 

.objects can use blob format
	=> faster
	!!! we don't need to merge object files if we use a db
	building large .object files (140 KB) takes 0.7s
		=> we need to be able to generate some statistics about any builder (with type , name)

timing/stat info: have an option to name the file where the info should be saved
	=> format that can be used by gnumeric, html generator, ...
	
time how much time is spend in the depender and how much is spend in pbs (digest generation, merging , ...)

keep dpt figures so a post pbs can extract them
	=> also in warp mode
	=> also keep other statistics
		md5
		build shells
		c depender cache statistics
		...

parallel build should try to extract info from distcc log (ip, ...)

--time_builders: should also display #node build, types, timing per node, ....

Valid unsychchronized cache could become the normal cache, thus having to verify only one cache next time

#C depender and builder: revert to normal depend if no object node exists in the tree

C Depender can use warp 1.7 format to speed up loading (+ use watch server)

#Check.pm: if node ! triggerred and no digest file exists and BUILD_DONE is set => Trigger but leave BUILD_DONE set!

new warp format: 1.7 and 1.8

remove warp 1.6

remove micro warp attemps from warp 1.5 and Depend.pm

$tree{BUILD_DONE}++ replaced by reason and show the reason later

#integrate TheBigO pbslib to main PBS

windows exe

emil's comments


build browser
	dhtml of the dependency tree
		=> display the state, size, ...
		=> build node
		=> ...
		
use log4perl and define std warn levels

some boilerplate functions
	#GetBuildDirectory
	#GetsourceDirectories
	LocateFile
	...
	
output directory name should depend on the config
	=>internal config or command line?
	=>this would put debug builds in debug output directory without having to tell pbs
	
single run variant builds

distributed pbs with zeroconf

Runshellcmd should have a 'no output' option

generate builders only when they are needed

multiple dependent => deps
	=> this can be done very easilly with a depender
	
add the possiblity to add a dependency but know nothing about the dependency
	=> late depend
	
gtk project manager (look at maketool too)

eclipse integration

generate/#read vcproj files

output everything and have a filter (settable at run time) display the output)

Support for remote build scheduling via XML-RPC, DBus, avahi.
 
config system

./configure support

some web based system to collect all the the latest builds

create node but do not depend them
	=> sometimes we want to define a dependency to a node without 
		knowing anything about it. We just know that something
		in the system is going to handle it sometime. As PBS works
		today, this is not possible. All nodes are depended and nodes
		without matching rules are marked as depended anyway

add possibility to register plugins (specially EvaluateShellCommand) per node

-e $file (in Check) could be replaced by a md5 check that would most likely be in the cache

Change watch server protocol to HTTP
	=> at least the stat page
	
#windows watch server

how to find Pbsfile and emil's bug report

#--display_parent ovverride
	=> overrides ':override_parent_config'
	
make all switches act on a specific PBS load package only
		=> lower output spam.
		=> filter the out put in an external viewer ?

Remove single node checker from PBS::Check
	=> not used anymore

#remove any remains of NO_DIGEST

#Add wizard for new prf format

#warning about using absolute Pbsfile path should use same color as relocation warning
#both warning should tell where the warning comes from
#Give feed back while checking

#AddGetConfigList that dereferences list config variables 

warp 1.6
	# source files don't trigger
	add subpbsfile triggering (trigger that have that as original package??)
	add shadow nodes
	add test
	what happends when a source node becomes a generated nodes
	what happends when a source node is removed but is in the cache
	The load package changes from run to run and can't be used as unique index
	#add some verbosity switch
		show md5 diff or not
		show the message for the node or not
		show a dump of the pbsfil dependencoes or not
	
Ignoring Builder from rule: #10 'eca_subdirs'.
	=> give more details in dpb mode
	
No builder failed message should include node name
	done but not in because of failing tests
	
error at check time => die, since we don't want to generate a warpfile
	=> return an error instead and see that no warp file should be generated
	
ispell all documents

^Add creator for C files

extra arguments to depender should be passed as a ref to @

Test for -gtg only if graphviz is installed

Information.pm could reuse some function defined in NodeBuilder.pm

check if $C_dependencies_cache and $Creator_dependencies_cache shouldn't be flushed

Release
	Batch::PBS
	#Data::Dumper
	#Devel::Depend::Cpp/Cl
	#PBS

The parsing and handling of the type of the rule should be left to perl	like we do with AddRule. 
	=> SR[], => PR[] ...
	=> we need overloading a la C++

ShellCommandGenerator in Builders.pm re-evaluates PBS_REPOSITORIES for every node
	but BuilderFromStringOrArray doesn't! in any case the way to re-evaluate
	PBS_REPOSITORIES modifies the config for all the nodes sharing the
	pbs_config.

	#what about the special %PBS_REPOSITORIES handling in Config.pm
	
handle -I vs /I in shell commands with %FILE_TO_BUILD
	
language simplified should also handle a plugin to make it possible to add, say, $build_directory, ...
	=> euuu! $build_directory in the dependency definition !!!!!???

We need a unified way to present output, whatever mode we are running in
	ex modes: progress_bar, -j, -ubs, -so, ...
	node header missing when node build fails (when not in -j mode)

C_Depender and warp 1.5 dewarpifier could be the same code

_warp 1.5 doesn't rebuild the ancestor tree
	=> OK, warp is not made for searching, only be fast

^ C dependencies cache doesn't rebuild ancestors properly

We should display a warning when intermediate file is excluded from digest
	=> intermediate files should _aways_ have a digest
	=> or is it nodes with builders that should always have a digest
		what about having a creator?

At check or just after, a 30 MB memory usage boost appears???

document what warp 1.5 does, specially regeneration

_ We rebuild too much! when C_depender changes, we should rebuild only if the dependencies change md5.

when compiling error occurs open build buffer in editor
	=> What about listing the file names somewhere where a post pbs or a script could take over?
	=> this assumes the build buffers are kept

^^^^ AddEnvironmentDependencies does not work with warp as do the other AddDependency functions (Add Switch)

-p pbsfile displays warning about relocating pbsfile ????
	=> couldn't reproduce at home!
	
Is LOCAL_NODES really needed when the node does have a a different path

META_NODE 1
	one node is multiple files in the filesystem
	examlpe: source file build as different variants but refered to as the source
	
Create a term and acronymes section

allow creation of builders that generate shell commands
	=>type the builders or modify all the builders to have a special mode (bof)
		ShellCommand(\&DoSomething, 'arg', 'arg') ;
		sub DoSomething : ShellCommandsOnly
		
	? should creators be tagged in that way too?
	
document how to write a builder override

^^Stop using closures!
	# have minimized some of them in the builders section
	=> generate builder when they are needed only!

_ verify config when linking to existing node?

_ parallel C depending
	it it possible to build the dependency graph without C depend, depend each C
	file separately and parallely then merge each C file dependencies back into
	the dependency graph

...? micro warp file for each subpbs
	=> usefull if the whole warp tree must be rebuild . ex a Pbsfile is changed
	=> not realy usefull in common case where pbs is run in warp mode
	=> might be used to speed up warp file creation which become a list of micro warps
	
	=> decentralize warp files.
		each warp file would depend on it's own dependencies instead for the global warp file to depend on all
		Only the warp file part would need to be rebuild. 
		We might even be able to restart building from a specific node instead for the root
		another example is subpbses, they could have their own warp files
	
	=> hmmm isn't this no more than adding the pbsfiles as dependencies to the nodes?
		=> except it is top down instead for bottom up!!!!
		
	=> if every node in the tree has a dependency to a pbsfile-node, a modification in a pbs file
		would 'trigger' the nodes, except that children to the triggered
		nodes must also be removed as we don't know if they are part of the warp tree or not
		
Optimize memory usage
	=> no separate packages for each subpbs
	=> no reload of rules
	=> hashes are expensive (but so cool)

find a pre_processor within a module

find a way to build with light weight processes
	=> worker pool
		socket communication so the workers can be remote if needed
	=> use an existing RPC module if possible

_builders using shell commands only should automatically generate warp2 stubs
	=> what about adding it to the tree through a node sub?
	=> getting it as a result from the builder
		=> builders can serialize themselves
		=> need a special mode when building Warp2 data
			for nodes already build
			
^when merging nodes in c_depender, shouldn't we set dependent too get ancestors properly?
	=> yes, __DEPENDENCY_TO should be set or we get an error.

^C file was removed when it couldn't be depended !!!!!
	made an error in the include path, forgot -I
	
Change ImportTrigger(file) to Import(file, Trigger) ;

...trigger inserted nodes are searched in $inserted_nodes only this means that trigger
	inserted nodes from a sub pbs with LOCAL_NODES will NOT be found!
	=> keep all the LOCAL_$inserted_nodes in a list
		this would make it easy to know how many nodes we really have in the tree
		warp 1.1 wouldn't neet to traverse a tree (hmmm, how do we rebuild multiple trees ?)
		The original $inserted nodes should be in the list too
		PBS could push $inserted nodes in the list when is is not defined .?

Remove spurious references to full path C files introduced by depender

make warp2 give the possibility to modify the warp tree without running the subpbs
make warp2 -j and - distributor aware
rewrite the rule generator so shell only commands can be warp2 enabled automatically

warp2 tries to regenerate the sub builder for a node
warp2.5, tries to use the wapr2 nodes within a normal pbs

... --load as for make

More resilience if a build  dies without returning any error
	time out? multiple_timeout and then kill?
	Restart the build? what if the shell was a fixed one?
	we must keep info on which node was being build
	
Catch ^C when building and die nicely
	=> show what builders we are killing and what they were building
	=> generate warp file
		=> complicated as warp needs the inserted files list and C can happend at any place
		=> none of the build files will get their md5, this means next run will be slow anyhow
	
distributor should be more dynamic than just handing a shell, they should be called when scheduling a node too.


...Should the build directory be based on a warp signature?
	on hold till we decide how to differenciate them for the user
		md5 is not user friendly
	what if we want to reuse most of what is in the out directory even
		if the config is slightely diffrent

what about a specialized filesystem to speedup dependency?
	we "serialize" the dependency tree and let the filesystem do the triggering
	this allows us to very fast know if a whole subtree has been modified or not
	Problems to be fixed:
		How do we serialize?
			FUSE FAm nullfs overlayfs portalfs
			
			each warp has a unique signature, we can keep a list of dependent in a warp signed file
			each file in a dependency file get a 'special' file named: warp_sig +  filename (ie X) in the
				directory where the file is. The fs checks that file (and all other special file with
				other warp sig for file X). The trace file (the special file) for a given warp signature 
				contains a list of all the dependent to file X and the location where to write the trace data
				if file X was to be changed. It could also contain the original md5 of file X.
				It would make sense to have the trace file to be a perl script that is evaled from the fs,
				this would be effective if we embed a perl interpreter into the fs, this would free the fs
				from the logic internals. All that need to be done is eval a file if it exists.
				
				If a perl evaluable trace file solution is choosen, this could be done:
					- check the md5 before doing anything else
					- write the list of dependent where the original warp file
						warp3 would evaluate the file to removes the nodes that need rebuild
					  alternatively we could link/move the signature file to avoid writting alltogether
					- a background build can be started  

				trace file should fire if the file is removed too
				
				? Could we remove the trace file? This would "trigger" a build just once.

		Multiple users, project, configs. Sometimes a single project might have multiple configs
			=> no problems with these says ALI
			
		?How do we detect if a files is fiddled with outside the fs control
			we can't gurantee it  => md5
			use warp1
			disable access in normal fs
			
	@ since we follow warp signature, we can find the sytem that had the dependencies
		the sytem needs to be rebuild when one of the dependencies is changed
		this means that we can start a build when a dependency changes thus having an uptodate
		system (for any of the builds on the fs)
		
		if no auto build is attempted, it is easy to write a tool that finds all the trace file that
		have been moved to the warp file's location thus listing the projects that need rebuild

Warp signature should depend on all the configs not only a choosen few
	problem with PBS setting data in config after warp checked the config
		=> PBS shouldn't do that and should require the config to be set properly befor pbs() is called
		=> we could separate setup data from run time data and generate signature from setup only
	if the config is set properly to start with, the warp signature computation always returns the same value
		=> cache the warp signature => cache the filename directely
	shouldn't we be dependent ont prfs content instead for its name
		we shouldn't use it at all but use the config instead after it has included the prf contents
	... warp file must md5 itself to avoid warp file corruption
		put this in a separate file
		? isn't this overkill ? who is going to change a warp file?
	#=> move $number_nodes_in_DT to the end and check for defined or not
      
Check the header file override problem
	must add include path
		=> change in the pbsfile
		=> must be documented

Can we distribute the pre-processing for distcc
	1/ let n boxes run pbs till the dependency tree is buils on all boxes (fs are synched)
		all boxes get the same build sequence
		the master builder gives a slice of nodes to build to the slave builders
		fs are synched
		
	2/ synch the needed files to the slave (do this smartly by building the nodes that have the same dependencies on the same box)
		by remoting the distcc call to another box, synch of the dependencies must be done to  the builder box
		if gcc is used instead for distcc, we get a normal remote shell build except for the synch (instead for nfs)
		if we remote multiple builds and use distcc, we get part of the parallel build pre processed on the slave box
			and the compilation distributed by distcc
		!! no need to install the any files on the slave box as the needed dependencies are automatically synched! we have the md5s

Can we distribute the dependency step
	fs are synched
	Distribute the subpbs
	each subpbs tree becomes the head of a pbs on the slave box.
	the master box (eventually) merges the build sequences and parralelize it to the slave boxes
	the config for the the common nodes (which exist on all boxes) must be verified as no linking can be done remotely
	if only few nodes are common they can be build on all boxes anyway, simplifying the parallelizer and build step
	when a common node is build on a specific slave, it must be synched to the other slaves waiting fot it
		best is to keep the nodes with dependencies on a shared medium.
	
	configurating, on the slave box, which subpbs is run on which box can be:
		- dynamic
		- simply through a local text file local text file can add rule with post depend which removes all nodes not to 
			be handled localy	another text file could also define the distributor/build_sequencer

distribution of pbs (see also distribution of dependency step above)
	if each pbs runs in its own process (box if really distributed), the master pbs will keep
	a list of inserted nodes and which pbs has insrted it. the pbses will generate their build sequence
	and let the master find out which nodes are going to be build where. some nodes must be transformed -by the master) 
	from "normal" nodes into synchronization nodes, their builder being replaced or exampanded:
		- on the box where the node is to be build, copy the generatedfile and send a synch signal
		 (to all pbses needing it) after the build is done.
		- on the boxes where the node is not build, replace  the builder by  a builder ttha waits for  the signal above
		- how shall this replacement be done? post build and pre build sub, which have the advantage of not
		modifying how pbs works
	
_pralellelisation of build is not optimal, build parents before terminal nodes.

Unify color used by -dji

Check variable names .....
	use check_word.pl (using PPI)

find all output strings and check them (ex parrallel)
	
Caching of PbsUse 
	red pen analysis done. => Intricate, might be possible in PBS2
	is it possible to get an eval reference?

Add information to node information dump
	#shell => display_shell_info gives a good enough result
	commands when using -ni => difficult as commandes are embeded within a closure
		=> commands should be added to the dependency tree when the nodes are created

... __BUILD_DONE, __BUILD_FAILED and fields set by builder subs should be done in the main process when using -j 
	maybe we should have a generic protocol ,between the worker and controller, to set attributes
	when re-written pbs OO, the node members could be remapped to a write data remotely
	the protocole is needed for warp2 as only the builder can return a list od subs or shell commands
	#-j 2 -warp needs 2 runs before doing nothing => because of missing __BUILD_DONE

have an "insertion line" field instead for adding it to the "insertion file" on -o

make it easy to regenerate a build from a log, including versions/md5 for the files
	having the md5 for the files doesn't help if we can't find the files anymore
	maybe we should make a tar ball with the files and the build system instead

generate a list of the shell commands (and perl sub stubs) that are needed to:
	# Add __BUILD_COMMANDS
	generate the whole build as if it didn't exists
	generate the missing part of the build
	
	This is warp 2! We need to rebuild the dependency tree when one of the node to be rebuild
	has a perl sub dependency. If no perl sub dependency exists, re-running the shell comands
	should be trivial and no require any dependency tree rebuild. even if part of the nodes
	are build by perl subs, we could run the rules on those nodes only not all the nodes.
	===>>> in fact we don't need to run the rule on the node as we know which rule is to 
			build the node, we could simply set the builder from the rule list if there is no
			builder argument. Running the rule to set the builder is in any case cheap.
	should warp2 regenerate the warp tree? ie when an error occures next run in W2 doesn't have the fields set????

dump tree in SVG
	needs to be embeded in html

support for autoconf ?
	generate a define list from the autoconf generate header file
	=> check autoconf perl module

Do we need a cache like CCache?
	=> NFS is bad! a local cache seems like a very good idea
	=> CCache make it worse localy!!!
	How do we search for a node in multiple repositories instead for stopping at the first found
	and eventualy rebuild while another node in the other repositories might match

Add switch for only showing a nodes data without it's child nodes data.
	! good idea but not possible before we type the nodes or use ^__ for all non node fields
	tying and blessing are orthognal but we still need to change all code that expects a HASH to a PBS::Node
	? should we bless or tag

... Defered build: build only what is needed to work now but queue the less important nodes (ex doc)
	should this be a rule attribute?
	should we let the user define new attributes and handlers?
		rule ordering could be done this way
		GenerateDepender verifies that the rule type is one of the registred types
	?! why should PBS be involved here? this has to do with builder and PBS knows nothing about builders
		builders that are not important should handle it themselves

Display: do not display build name if it's the same as the node name (for the html documentation)
-gtg_html: insertion rule looks weird!

PBS server could cache the subs only and we keep the tree in warp form.
	it should be possible to re-generate the subs if necessary
	the warp file could keep a guid for the builder sub to facilitate finding it when needed

give OO interface as well as non OO interface:
	we should be able to start independent builds (OO interface) but let the builds use non OO interface in the pbsfiles.

Make Pbs a build server. Computes build sequence from rules. Rules come from clients written in any language.

Build server could cache the Pbsfiles and the dependency tree for next run
	Check phase could be replaced by MD5 verification (sortof warp on live data)
	
Warp2. Generate a "perfect" monolitic build system for the configuration at hand. (we still run rules)

Warp2-3. Extend Warp1 with build code that can be evaled and run when needed without needing to load Pbsfiles.

Warp3. Look at the warp tree like a build sequence instead for like a dependency tree. The build sequence becoming PBS

Warp4 when a warp3 build sequence must be rebuilt, only the changed part is re-generated.


? how de we handle ['./inc/file' => 'file'] so it works ?
	=> use TARGET PATH
	=> use real depender

Check and document LOCAL_NODES
	warp works fine with local nodes even if the inserted files do not contain all nodes
		because the nodes removed from the warp tree go up to the root
		and the 'root' is always in the primary inserted node list.
		

package PBS + perl + build system + source so it can be distributed.

Front end in other languages: python, ruby, ... ?

-warp and -j when the terminal nodes are already build.

C depender should evaluate -I paths to reduce . and ..

triggers and subpbs are virtualy the same
	instead for linking the node by hand in a subpbs, simply link it from the inserted nodes

add ./ to targets at PBS::PBS start BUT not when defining the root rule, or ??

Bundle

gtg_gm 1+ seems to crash GraphViz when used with gtg_p

Re-intrency

_ redirect stdout/err to file even when not using -j

_ INHERITANCE of PBS_CONFIG and CONFIG should be done through reference and override instead for copy

##############################   Done   ########################################

#Add GetBuildDirectory directely accessible from a pbsfile

#duhh! nadim@Korba /devel/Qix/QixApplication $ pbs -ndpb
Illegal division by zero at /usr/lib64/perl5/site_perl/5.8.8/PBS/Warp1_5.pm line 98.
in warp file $number_of_nodes_in_the_dependency_tree = 0;

#Error when pbsfile is not found
	Reading from filehandle failed at /usr/lib64/perl5/site_perl/5.8.8/PBS/Digest.pm line 214.
		...propagated at /usr/lib64/perl5/site_perl/5.8.8/PBS/PBS.pm line 599.
	PBS run 1 building './AllRessources' with './'


#$shell_command =~ s/\%FILE_TO_BUILD_NO_EXT/$path\/$basename/g ;

#patch or immediate build in subpbs builds twice in Depend.pm:1066
	if($tree->{__IMMEDIATE_BUILD} && ! exists $tree->{__BUILD_DONE})
		{
		PrintInfo2("** Immediate build of node $node_name **\n") ;
		my(@build_sequence, %trigged_files) ;
		
		my $nodes_checker ;

#Make IMMEDIATE_BUILD less noisy

#-w postpbs is not a wizard!

#Add the html documentation generation script to pbs

#directory cleanup
	scripts
	watcher modules
	todo and div emil docs (integrate)
	documentation
	pbs completion
	project generator
	win32 specific scripts

#merge Adsubpbsrules from work

#Document the fact that warp1_5 doesn't have a warp tree

#relocated Pbsfile is psycho!
	=> rewrote and added switches -display_subpbs_search_info -display_all_subpbs_alternatives

#Postpbs doest get a valid dependency tree if the build failed
	return error code instead for exception
	
#add link to rt.cpan.org

#Apply patch 

#Remove spurious PBSFILE HELP for -hu -hur output

#? AR [x => y], BuilderAndCreator(\creator) ;
	=> AR [CREATOR], 'name', ['A' => 'B4], "touch %FILE_TO_BUILD" ;
	
#Check if CREATOR can be mixed with other rule types
	#=> including CREATOR multiple times

#Should we ignore (or even warn) if  a rule with creator also has a builder?

#wizard info and help

#Get the C depender (and other dependers) to exclusively use PBS md5 functions instead for defining it's own. 
	Let PBS check the C digest
	=> used warp1_5

#Warp 1.0 (new) and 1.1 fail regenerating when an error occured
#... remove all non perl language interface: ie use regexes
#... simplified language could translate to perl regex.
	# add the possibility to 'PbsUse' the translator => see language directory

	=> fixed but discuss fix with Ali

#^Log of 230_000 lines for 700 nodes is a bit overkill
	#this is a good candidate for a plugin

#add file name filtering function
	? through a pbs config, ie AddPbsConfig DEPENDENCY_NAME_VALIDATOR => sub{} or regex

#Triggers use simplified regex and should use perl regex instead
	=> had to temporarely add GenerateSimplifiedDependentRegex to Trigger.pm
		so it could pass tests

#Subpbs regex definition should use pure perl or be overridden
	=> hmm think it is already a regex

#AndMatch should not assume code but verify it at 
	PerlBuildSystem-0.28_10/PBSLib/Dependers/Matchers.pm' line 68.

! use make as a distributor !!!
  make consumes 2M before it gets any input, so no significant memory saving
  compared to Perl Build Server.

! -dac should be better indented and give better info in a better format
	#verbose but not so bad
	=> maybe a regex for what keys and/or packages and/or pbsfiles could be good

!can we thread the depend step too?
	yes, and merge nodes if they should be linked but what's the use? there is very little IO involved so threading doesn't help
		better to distribute it

!Add insertion time to node display

!generate tree with color graduation depending on the insertion time
!Rule to verify that no C files are forgotten in the directories from where we get source for the build ? (repository??)

!Revise the fact that all the dependers are run. We could mark some of the rules as terminal and speed up the depend step.

!?top level Pbsfile modification should make all sub levels rebuild because of the parent configuration change.
	Supbs are NOT dependent on their parents config. Every config that should be used in a subpbs digest must be declared. We could introduce a function to do that.

#Give more info when ignoring a builder.
	=> What builder will be used
	
#wizards are broken
	=> was bad line termination
	=> TheBigO wizard were in PBS group

#Release DevelDepend Cpp Cl and add them to the dependency list

#%xxx should be handled in a single place

#Add plugin for:
	#add other %XXX not supported by pbs
	#file name verification
	
#fix group ownership in t and other directories

#display subpbs run and depth and displaying full information
	=> run 95 in world takes long time. Which one is it??
	added to display when using - dsi -sfi
	
#pure perl rules must become standard and a simplified user module should exist

#Add Term::ProgressBar to PBS

#Tag node names with Perl/shell builder
	=> -dbi

#builder_override should not be taken if it is undef or a nice error message
	is needed. check the checking code too.


#add %FILE_TO_BUILD_PATH  %FILE_TO_BUILD_NAME

#fix emil's find include module and 'TheBigO Pbsfile' wizard

#less output when C file needs to be re-depended

#--display_different_digest_only should set display_digest

!let the C depender get part of the digest as an argument
	=> write a digest parallel to the C digest

#handle broken pipe
       => fixed one error with unhandled exception.
	!re-try the build ???

#META_NODE 2
	one command generates multiple nodes
	=> this can be implemented independentely from PBS by letting the builder "know"
		if it has already been run or not
	
#--ni is broken

#How do we mark a perl sub builder as only using shell commands?
	should those be run just to generate the commands so we can remote them?
		=> added it as rule attribute
		
# time_builders should show time spend in nodes build by perl subs versus node not using perl subs in their builder

#should -bni show more about the builder, specially USES_PERL_SUB ?


!log plugins calls

#look at all the switched so silent mode is default

#Total build time is not displayed in forked build

#Warp file version is not verified
	in warp file
	in C dependency files
	
#Env variable do not work as targets in PRF file.

#AddEnvironementDependencies has an extra e

#Add "No matching rules" when a node fails to build and it has no rule matching

!How to handle configuration setting at subpbs level
	=> run project but filter which subpbs comes in => always up to data config
	=> dump an evaluable config at each subpbs level and add a use config switch
	=> Do as in Nailara

	=> Can be handled like in Nailara; PROJECT_CONFIG on
	command-line, ...


!Can't we reduce the dependency tree on the fly (warpification) when all the data are not needed
	=> doesn't seem to change a lot
	what about serializing the live data once in a while?

#^Forced doesn't work with warp 1.5

#^^problem with cyclic dependencies that desappear.
	=> this was fixed once already! 
	had to do with cycle desapearing because of linking when mergin the C dependencies cache (I believe)


#PBS_CONFIG should be reduced before it is passed to PBS
	# no diffrence
	
#parallel builders should use a single communication channel

#silent mode should be default
	=> builder process output should only be displayed when error occurs
		=>support was added to Forked.pm but is not used yet.
		
	=> this is even more true for parallel build where display is
	so fast that it makes no sense and uses resources for nothing

#progressbar in depender
	=> heuuu?
	=> DISPLAY_COMPACT_DEPEND_INFORMATION

#type creator should be added through node sub
	=> not possible as it is used before node subs are run. Cleaned it a bit though
	
#Compute a newly build node MD5 directely after its build as it is fresh in the cache
	=> Generating Warp 1.5 takes 30 seconds
	
!Computing the build sequence while checking a warp 1.5 tree is trivial
	=> it's also possible to take a "full" build sequence and remove nodes that are not to be build from it
		parallelisation is more complicated in this case
		
	=> when running warp, the checking is only done on unbuild nodes (warp checks the build nodes)
		in TheBigO world the checking only takes 2 seconds for 5000 nodes

!Derefer builder generation till the node need to be build
	=>we could get PBS run time errors instead for PBS "compilation" time errors
	# faster depend => in argus2_test diffrence is 5/100th s
	lower memory usage
	
!install pbslib directory

#? add a perldoc like documentation that would extract the function help directly from the modules
	? pod::find + Pod::Select + Pod::Text

!Should the md5 of a C file be generated from the pre-processed source?
	what if we generate documentation automatically from comments? => wouldn't work anymore

#!plugin should be dynamically loaded instead for batch loaded (? should they)

#!Addconfig XX => undef ;
	=> undef is a value like any other but we need to document this behaviour

#!Clarify Hosted vs Distributed shell and how to use them
	? where

#!make xx.c.depend files depend on the depender module => nothing depends on PBS so far

#check if we can make the digests smaller
	=> warp 1.5 digest
	
#TIME_STAMP_SYNCHRONIZING for c files could be entirely removed!

#named user defined dump filter ex: -tdhtml -tuf only_names.pl
	write a wizard for a 'tuf'
	the whole --tt could be moved to a user post build module instead for being in PBS
	we should be able to queu post build scripts
	we could pre process the command line to add user specific switches instead for long post_build commands (ie -tt => --post_build something.pl)
	we must also display help for those user defined switches
	user defined switches should always start with a specific letter or letter group
	the user plugins could be set in a specific directory and found automatically

!? lock directories, if the directory is locked and the lock id hasn't changed then no
	node under the directory has changed and needs to be checked or rebuild, just used

#!? --preamble --postamble 

#Understand: __PBS_FORCE_TRIGGER
	The C depender can find out that the C file must be rebuild, it
	adds a __PBS_FORCE_TRIGGER dependency to the C file dependencies.
	PBS will force a triggerring when this dependency is found.
	Rule/C_Depender handles _all_ the dependencies for a C file because
	we do not generate digest for H files. Something must trigger from 
	the H	files level => C_depender with __PBS_FORCE_TRIGGER

#!number of build threads could be dynamic

#keep all commands output for post analysis, ie # warnings , their types .... => on switch only
	--post_node_build perls_script.pl (per node only, no global loggin, the user perl sub can do that if it wishes)
	=> --kpbb
	
#Verify existance of post_pbs file before running.
	#error message too verbose

#Look at Make::Cache and Schedule::Load

#we also want to define which shell is going to build a node
	!when the node is created
	!when creating the build sequence
	#when scheduling the node => the distributor get access to the build sequence and can set unique shells for a node

#remove unnecessary code from triggers
#comment format for triggers input data
#add triger sub => was already done

#dump of triggered tree should show inter trees dependencies

#Let PbsUse take a list of files

#We have two implementation of Md5Tagger!
#we have two GenerateWarpFile!

#partial warp / lock / unlock from command line
	? dynamic load of warp componants ?
	=> simply consider the componants to be final instead for try to depend them!
	
#Sequential Build should also honor -kpbb
	=> let -j 1 handle this

#Can warp be made faster by creating a build sequence and use it as
	a list of md5 instead for having the warp tree and checking the md5 
	by traversing it.
	? do we even need to have a warp tree?
		=> the tree is what gives us the dependencies between nodes thus which node
			to remove when one file has changed. This could be replaced by another
			structure (list of dependents) so we don't need to run PBS to find out what
			nodes are to be removed from the %inserted_nodes. The list should be ordered
			so we can eliminate nodes instead for checking their md5.
			
	#We shouldn't need to count the nodes in the warp tree! We know that
		when we write the warp tree
	=> implemented in warp 1.5
	
#what if the source directories are added to the C depend file forcing a rebuild?
#	C file dependency cache is dependent on CFALGS_INCLUDES thus forcing a rebuild

#Output subs should check their input for undef

#AddConfigVariableDependency
#AddNodeConfigVariableDependency
#	AddVariableDependency is evaluated when the function is called
#	AddConfigVariableDependency is evaluated when the digest is generated


#define documentation command line syntax
#pbsdoc -f -s ?? info page?? => generate html documentation with links

#^Virtual nodes have no digest and can be dependent on source file that have no digest themselves
	=> Have a null builder for the file
	
#Shouldn't trigger inserted roots (in warp) be ordered to guaranty the same build order every time ?

#vi out_nadim/nailara/os/mem/poolheap/PoolHeap_AllocAndFree.o !!!????

#rebuilding without warp after a warp build does build stuff !??????
	Warp should update the rebuild nodee digest so running a non warp after a warp doesn't force a rebuild

#Warp 1.1 doesn't support Triggered tree

#Warp 1.0 erroneously reuse the dependency tree it has evaled! it should use the one returned by PBS::PBS::Pbs

#Config options can be call global
#	AddConfigTo 'color:SILENT_OVERRIDE' =>
#		 white => [0 0 0]

#post_pbs can be a plugin

#add switch to not show header files in -tt -tno

#Make C_Depender --sd aware for digest files

#Move -tt to plugins

#documentation module is buggy

#plugin architecture
	#find plug ins automatically
	#register the defined function automatically
	#register command line switches and their help
	#documentation module should search the plugins too
	#plugins can be unique or in a list
		what is acceptable?
	#add --pbs_plugin_path

#? generate warp file more than once ?
	#IWW
	#? separate warp file and MD5s
	
#AddPostBuildRule has arguments, should we keep them?

#?  seems that the dependers ar not passed all the arguments they expect
	=> they are in the rule context

#Generalize AddRule to take a sub instead for a build argument
	AddRule 'name', [], builder, '-02' becomes AddRule 'name', [], builder, BuilderArgument('-02')
	Could be used for: HostedBuilder, debugging (though -d is better)
	? who is going to run the sub, the builder, the depender, ... 
	
	Should Rules also have a sub run when a node is created
		AddRule 'xx', [], undef, args, [sub, sub, sub]
			=> replace args with the more generic sub
		This can be used for
			- arguments
			- node builder timeout
			- host shell
			- config
			- pbs config
			!- subpbs
			!- ruleset( exclusive, additive substractive)
			!- exclude from digest
			!- debuging ??
			!- post_build_rule
			
	
	the subs can be defined in modules that need the information later when building the node
	
	
#-warp can't run when no build is made as the build generates data for warp
	=>make it more resilient

#hosted builder checks to see if the command is a sub ref but an array ref might contain sub refs
#	and that is not checked. should subs always be run locally even if the builder is remote?

#Add shell override to support distributed build
#Add distribution switch and file format
#we need to control how many local builders we use when --distributed

#Builder sub wrapped twice when using HostedBuilder

#existing file while Virtual warning should show some stats about the node and if it is a directory
	#should we warn when it is a directory?

#SHELL_ORIGIN is not set properly

#can we build a build cluster

#distributed builds.

#dump tree in dhtml with inter-node links
#we used to be able to generate a graph from a log, where did it go? => --dump

#change default build directory to out_$user_ame
! mandatory_prf
! global prf
! warn if global prf is overridden

#catch AddRule without name (ex the first argument is an array ref and contains
	#the depender instead for VIRTUAL ...

#exclude from digest should verify the arguments type
#Add warning when overriding exclude from digest

#subpbs package names should be unique ????
	#can't do that
#do we need to set package names for subpbses ???? => indeed

#remove references to c depender simple from digest.
#GenerateBuilder has changed package.

#! was slower! use md4 instead for md5. Make the digest function a pluggable one.

#colorgcc doesn't color if stdout is not TTY.
	the problem came from colorgcc which doesn't color if stdout is not a tty
	another problem (bug) was that colorgcc added an ANSI reset code for lines that are
	not colored which made arm ld croak!!

#forked build has bad module path!
#forked build doesn't work. FindUnique node dies.

#sudo cpan install Tie::Hash::Indexed
#sudo cpan install Devel::Depend::Cpp

#alias gtg_snapshot and gtg_snapshots

#gtg_snap_shots needs gtg_tree !!

#C depdndency time must be after C node insertion time if we want snapshot to work.
	this is due to the fact that C dependencies are cached in the .dependency files and their time is 
	the time the dependency file was generated

#gtg_frame didn't generate output

#make it easy to use language plug-ins (language can also define their own functions to replace 'AddRule')
	PbsUser Language/Simplified ; # override built-in AddRule
	AddRule [...], ['*.o' => '*.c'] ;

#how to have the same node with multiple configurations
	when linking, check the config
	if config is diffrent push a new config in the node instead for a new node in the tree
	check the node for each config
		which means that the build name and other infor must be config specific instead for node specific
	build sequence
		? do we build nodes first or compiler first (or other config)

# was already done. __BUILD_DONE should be handled in Build.pm

#add why a node failed to build in the tree so post_pbs can report it
!add the build time and where a node has been build to the node information

# it does now! Does PBS exit with an error code when the build fail?

#Possibility to give a script to be run when the build is finished (to generate reports)
	#give it access to the build tree
	#is it when pbs.pl or FrontEnd is finished?	

#?Why can't we overide a parent configuration variable in the command line definition of a sub pbs?

#add breakpoint on variable setting

#LOCAL_NODE break warp

#! LOCAL_NODE could be a sub LinkToNodes{}

#Speedup pbsfile loading by cloning subs
	=> doesn't work so good, time is mainly spend in the registration of rules and config
	? could we clone the rules and the config?
		how do we check so that dynamic actions are done right?

#output should be tabbed with the pbs level (ie 0 tab at level 0, 1 tab at level 1, ...)
#	No manual tabing should be done within a single multiline output

????
#?warn when linking to a node with different config
	#user registred function can do that

!!!! ios.h
	#AddRule 'subpbs_name',
		{
		  NODE_REGEX         => 'i_os.h'
		, PBSFILE            => './pbsfile.pl'
		, PACKAGE            => 'test'
		, PBS_COMMAND        => DEPEND_CHECK_AND_BUILD ;
		} ;
		
	#AddRule [POST_DEPEND IMMEDIAT_BUILD], 'all', ['all'] ;
		how doe this react when run as child pbs
		
#missing breakpoint wizard 

#standing ithreads problem

#if depender definition is an array and first arg is a sub, call it to know 
	#if a dependent matches this would allow for
	#	[ Any(qr/xxx/, qr/ccc/) => 'cc']
	#	consider it as  pure perl rule?
	#	Any, not
	#	, \&sub and documentation

#--time_stamp_checking

#forked build
	#reuse processes
	# redirect the output and log

#--timers

#--verbosity and -V

#show that warp is verifying

# Node locator

# GenerateMetaRule verifies the default rule is part of the slave rules

# rule name is not displayed when using -display_dependency_regex

# --durno

#connect to telnet when needed only

#display class in --dr

#rules with creators are pre depend rules

#--pure_perl_rules

#warp problem with triggered node
	#!shall a trigger which is not a dependency of the triggered node trigger it again or not?
	
#!?builder argument must be packed with builder in array ref

#Depender sub and Creator sub have a non standard argument order
	#GenerateRule accepts depender and post depender subs


#add host information to graph => not possible!

#changed log-dump-warp header code
	#verify variables
	#use common code

#config: first override
#-inpulse
	#always use warp file generation even if build fails
	#fixed -warp when build is not attempted
#VIRTUAL should not trigger automatically
#warp. make build/pbsfile digest and re run pbsfile that need to only

# make Graph modules loading dynamic
# RunShellCommands returns 1 or dies
# rebuild c file when digest needs to be rebuild
# local h file is not recognized automatically, C digest should be removed
#allowed Pbsfile override, NON_RELOCATABLE_PBSFILE
#dummy sub !

#? remove -no_triggered_build ?

#Re-test object file repositories, special attention to config

#simultaneous variant build
	#build 2 nodes at 2 diffrent places with a different config

#distributed /heterogeneous build => need example (with secure conection)
	#it's the builder reponsibility to get the node build where ever that is
	#what should PBS provide to the distributed builder to let it do it's job?

#gtg_printer: graph should show trigger with symbole instead for red color only

#!?dump config and die

#shell

# refactor Rules.pm
# changes switch to depender_definition
# change builder_sub to builder_definition

#builder can be defined as a single string or an array of strings/subs or a sub

#-dpu 

#header files dependencies.

#object files depend on CFLAGS
#?object files depend on CFLAGS_INCLUDE
#!object files or c files ?

#IMMEDIATE_BUILD

#SILENT_OVERRIDE

#Data::TreeDumper wrap options

#if multiple PBS runs: log should be uniq for the global PBS run.

#in AddConfig replace $UPPER with it's value
	#use same code as for rules
	#% <=> what should we use in front of the variable to be evaluated?
	#test with nailara


#Nailara doesn't recurse: %PATH_REGEX
# no! ?EvalConfig should be called at 'GetConfig' not 'AddConfig'
#? TAGET_PATH => %TARGET_PATH

#PBS::FrontEnd, 
	#use front end directly in a rule, give Pbsfile as a string
	#pbs must exit with error code set
		#does that on die
		#Default build doesn't return exit code but build sequence 

#check if sd path is added to depender -I list
	#must be in CFLAGS_INCLUDE
	#%PBS_REPOSITORIES
	
#default colors
#$DB::single = 1 if(*DB::DB{CODE}), test is not needed!

#check BuildSequenceMiners after latest changes

#inserted_files should be called inserted_nodes! but we have inserted_nodes already !!!
#add run stamp to PBS package => was already done

#'.' is not a valid build directory (neither '../xxx' I think)
#evaluate path and eliminate . and ..

#--dump at same location and name as log
#Add tree generation sub in dump

#licence
#? Post depend rules are not sorted with each other. They are as they come from an array

#input file names
	#Pbsfile.pl  could also be pbsfile.pl or pbsfile or Pbsfile
	Pbs.prf should be dependent on user
	Prf file should be the one where the top Pbsfile is not the local one
	#display error message if multiple files are present

#? shouldn't -tt show triggered trees too?
#make PBSFILE fullpath and relative for subpbs
	??? was that a good move? see trigger example

#make BUILD_DIRECTORY fullpath for subpbs

#MD5 dependencies: Should we have global digest or per node type?
	#AddPbsUseDependencies(); moved to the pbsfiles or a switch to not have it automatically
	#=> if NOT_A_PACKAGE_DEPENDENCYis given as second argument to PbsUse, it is not added
	
	#AddConfigDependencies(); # is that missing ? use AddVariableDependency
	
	#?AddVariableToDigestForNode(regex => variable_name => value) ;
	#AddNodeFileDependencies
	#AddNodeEnvironmentDependencies
	#AddNodeVariableDependency (?Dependencies)
	#AddNodeSwitchDependencies
	
	#?Should Rules/C add package dependency on CFLAGS (etc) ? Yep
	#GetNodeDigest
	#--dump_node_digest node_regex => display_digest
	
#--a doesnt add ./ in front of node name => it does! recheck with staffans example
#--bi '*/*' doesn't match sub node names => it does! recheck

# user_name.prf
#-build_directory on command line doesn't override switch from prf.
	#seems to work at home on legend project, test with nailara

#rule number is node needed when using --dd
#change digest format so all non dependencies start with '__'
#? can we define -dd for a subpbs only => yep and undef it too
#gtg_legend => write a Pbsfile to generate it

#test autoloading

#GenerateGraph: pass config

#bug!! in data::dumper::sorkeys =>md5 => graph.pm:500

#gtg_animate: #invisible nodes?
	#change to snapshot
	#use argument
	#!? generate html for each snapshot?
	#!?scale down
	#node visible only when one parent is visible or always genereated gtg_tn ?
		#? is it really better ????
	#speed up !

#still some Dumper to be found around!!

#Dump tree switch to be able to re-create  graphs

#Triggered inserted nodes
	#do a manual depend, link to existing nodes and make node available for the rest of the tree
	#when done check if the new root has been build
	#can triggered nodes have attributes? No they can't

#Triggers broken and repaired!
#LOCAL certainly broken. => Repaired
#__RULES data structure => array[hashes]
# dependency hash
#remove __dependencies
#c_depender broken because of hash usage !!

# -PbsUse switch to include global config?? or use a config to config which config to config

#gtg_html with tool tips showing the rules and configs

#debug
	#Break on insertion( node_name regex), tied hash ? problem with subpbs??
	#types: depend build post-build insert tree
	#Breakpoint('rule_name regex + node name regex', depender => {pre/post}, builder => {p/p}) ; jump into perl debugger?
	# console (cmds: dump node, gen graph)
	!?dump debug data directly in the html/graph
	#?inactivate bp instead for removing them
	#p_ab ActivateBreakpoints

#__INSERTED_AT should also be a hash
#debug color
#OverrideParent and Local config
#AddSubstractiveRule => removes dependencies  , already possible with POST_DEPEND
#Target_path == undef ???

#Replace some of D::D calls with D::TD
#time module loading, remove some modules

#PATH_REGEX => PBSFILE_PATH => TARGET_PATH
#-create_path_node not always needed, is it depender that creats the path?
#Generate a tree like text output
	#use ansi hack
	#wrap text properly
	handle ref #SCALAR, #REF LVALUE IO::HANDLE and #objects
	#add max depth
	!send extra info to be displayed from filter
	# change names in filter
	#wrap 
#data dumping done only once instead for each subpbs
#Create log module
#replace -tno output by -tt style output => -tno works with -tt and -t
!Do we want a script to change it out directory depending on the configuration?
	!or to have the ability to check the Pbs config
#--sco no command output unless error
#graph remove *.c
#graph add toto.c
#No such build point should tip on the name
#Can't locate gcc in pbslibpath => add where the pbsuse was issued
#sort switches and targets from response file. was already so
#make .c dependent on .c_dependency => use digest in C_Depender. ? should we include the c file digest?
#Does system die if shell dies ? ex command not found? No.
#automatically touch C file, switch for not doing that and for generating a touch list
#Verify the message 'you should touch xx.c, I think I modified it at work ?? --dcd
#isa??? inc c_builder, check examption handler. OK verify with Ali
#C_depender: add the dependencies timestamp and rebuild if a dep has changed
#Wizzard
#	missing subpbs wizard
#	allow names
#	build menu automatically
#	search automatically in all wizard
#	name and availability in comment in pl file
#	wizard groups
#2 dumps of the ancestor? Added a separator in output
#Add name of file in digest file
#/^SHOULD NOT BE USED BY BUILDER/ !!!!!
#Remove GetPbsConfig and GetPackageFile
#how do we make the digest aware of the config subpbs inherit? Pbsuse a file defining all digest dependencies
#make no_link_info the default, should linking info be given only in inter pbs case?
#No digest for virtual files?
#Node_regex $something/xx => doesn't seem to add './'
#config is displayed in the graph, but what about the PBSConfig, ex build directory?
	important is :
		#done build dir, source dir
		locked, no external link, no digest
		user options, 
		
#document composite nodes
#-dr displays 2 messages for subpbs rule
#PrintUser, PrintWarning2, PrintInfo2
#Config: Merging rules for locked rules. If the user wnat to die if a config is set otherwise, then he can check and die himself
#Wizard files uses deprecated PBS::P....
#Config variable doesn't exist, display only if switch is set
#ok,triggering nodes are not always dependencies to the triggered node, which PbsConfig should it have then (build dir)?
	# display in graph
	!emit warning
#ReplaceRule
#-ni like -bi but at check time
#rename package config to pbs config and __PACKAGE_CONFIG to __PBS_CONFIG
#-gtg_cn *.c
#PbsSwitches.pl = command line switches from file, including targets
#oddinfile like utility, wizard -w, template.
#Multiple O compile: what if some C nodes are in the build sequence ? ie local nodes, ...
#couldn't fin any solution for <----------O-|>
#Should sub pbs use the config already defined or use a new one?
#display if a config was locked
#gtg_config gtg_config_edge
#-bi node_not_to_be_rebuild, show message
#multiple -bi
#No import info switch
#clean Depend.pm for temporary unique dependencies
#-gtg_sub_tree   generate graph for part of the tree. done if composite target
#-gtg_cn [./]* accept * without ./
#Locking => can be done without pbs: die "message ..." if ($ENV{USER} ne 'nadim') ;
#ImportTriggers

#on-line switch documentation
#split PBSConfig in a module and data module where we can have more documentation
#gtg_bd deep recursion if cyclic dependency detected
#cluster a node and its dependencies
#Node inserted by meta rule, removed, re-added, links. why?
#triggered node displayed strangely  when using ali's pbsfiles
#no: does sub pbs always add ./ even when already present in the root node name
#ALIAS for sub pbs definitions
#*/xxx regex doesn't match names starting at root
#gtg_?? cluster the files depending on their source directories
#-gtg_bd should not show bd if same as node name
#works as expected, reverify: -create_node_path seems to be the default
#-build_directory / gives error must start at root
#was OK, modification vs acces time for files
#-h should prevail on PBS_FLAGS
#no_ignore_duplicate_dependency message
#typo madatory

#show pbs call depth when --dds

#Cyclic dependency display

# graph
#graph: show nodes inserted by triggers
#graph: handle multiple tree roots

#CheckDependencyTree should return if error instead of dying so we can generate graph

#Pbs shell script.

#! can use --bi for that. -dt could take a regexp, multiple -dt
#-dd could take a regexp, multiple -dd => -ddr
#how do we run the same target in all the sub pbs without having multiple defined node names, name alias ?
#was OK from the begining. what happends with /foo/1.c and /foo/bar/1.c
#can we define a regular expression for sub pbs like: ./path/*.lib
#node name should be ./node name, ./ added if needed
# display_dependency_regex
# added self referencial show error line
#fixed:when adding a dependency check if the dependency is already a depenedency to the node
#target root:node_name, builds dependency tree from root but only builds node_name (tested with sub pbs too)
# -create_node_path, Verify the path for a node exists before calling it's builder
#--dps add ## end of file for easier reading and file name  too
#x... triggered on y, z, show if the node is virtual or forced.
#in message, mixing Dependencies and undef, we should show the origin
#switch to warn if no build directory is given
# b-A-AO-BO order
#--sd ./kfkfkfk

# threadpool: Ithread sucks!

# 2 paths to PBSLib

# !!!! Buuuug! handling dependencies as relative, full and xxx changes the insertion order

# DefaultBuild returns build sequence if no building

#remove arguments bd and sd as they are passed through the package_configuration

#rename package_switches to package_configuration

#change 'pwd' as we now use a cygwin perl.

#-o shall not modify the rule name but add info somewhere that we can retrieve.

#warn if 2 rules with same name
#think about (*.o: *.c *.s)

#object repository and salt.

#in rules.pm fix $prefix = $1 || '' to use length instead.
#use threads only if perl is compiled with threads
#-be check if message is set before printing

#overide PBS_FLAGS

# \n when using -sc

#-j8

#C source depend

#-D HUGIN = 1 => Config::PBS::CommandLineDefines

!-ddrd 'name', what for ???
#-dct isn't working ?


#LD instead of config->{LD} if exists
#$dependency_list to [shell_cmds]

#lock config

#typos allways locally origine
#which config does a sub pbs use?
#IGNORE_LOCAL_RULES
#'main.o' : '*.c' => warning

#handle [] Builder description

#Shell exception ?????

#Export OK and switch no_export_ok

#-warning color 'yellow_on_black'

#Skeleton depender, builder examples with arguments on one line please

#Missing quote meta on dependent regex arg!!!

#self referencial error display 0xArrays...

#context and color for some display data

#ancestor trim spaces
#*.c:.h vs a.c:b.c

#check local copy!
#check why target are not build in the right order.

Package in exe.
#Local vs repository : if top level target builder not called copy file from the repository?

#help for the make file
