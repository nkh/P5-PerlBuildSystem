
use strict ;
use warnings ;

PbsUse('Rules/C_EvalShellCommand') ; # add %C_FILE ...

# ------------------- Check Configuration -------------------

unless(GetConfig('CDEFINES'))
	{
	my @defines = %{GetPbsConfig()->{COMMAND_LINE_DEFINITIONS}} ;
	if(@defines)
		{
		AddCompositeDefine('CDEFINES', @defines) ;
		}
	else
		{
		AddConfig('CDEFINES', '') ;
		}
	}
	
AddConfigTo('BuiltIn', 'CFLAGS_INCLUDE:LOCAL' => '') unless(GetConfig('CFLAGS_INCLUDE:SILENT_NOT_EXISTS')) ;
	
# make all object files depend on CDEFINES, it will be added to the digest
AddNodeVariableDependencies(qr/\.o$/, CDEFINES => GetConfig('CDEFINES')) ;
# above needs to be completed! also note that .o can be have multiple source type
# CC_SYNTAX => "%%CC  %%CFLAGS   %%CDEFINES  %%CFLAGS_INCLUDE  -I%%PBS_REPOSITORIES -o %%FILE_TO_BUILD -c %%C_SOURCE %%C_DEPENDER",

# ------------------------- declare source file types -------------------------

for
	(
	[ 'cpp_files' => qr/\.cpp$/ ],
	[ 'c_files'   => qr/\.c$/   ], 
	[ 's_files'   => qr/\.s$/   ], 
	[ 'h_files'   => qr/\.h$/   ], 
	[ 'libs'      => qr/\.a$/   ], 
	)
	{
	ExcludeFromDigestGeneration( @{$_} ) ;
	}

# ---------- rules ----------

PbsUse('Rules/Object_rules_utils') ; # for object dependencies cache generation 

# set of rules to pick a source file for object files
AddRule 'c_objects',   [ '*/*.o' => '*.c'   , \&exists_on_disk],  GetConfig('CC_SYNTAX') ;
AddRule 'cpp_objects', [ '*/*.o' => '*.cpp' , \&exists_on_disk],  GetConfig('CXX_SYNTAX') ;
AddRule 's_objects',   [ '*/*.o' => '*.s'   , \&exists_on_disk ], GetConfig('AS_SYNTAX') ;

# make sure we only have one source
AddRule 'one source', [ '*/*.o' => \&OnlyOneDependency] ;

# object dependencies cache rules, has to be last as previous rules check for single dependency 
PbsUse('Rules/C_depender') ;

AddRule 'o_dependencies', [ qr<\.o$> => '$path/$name.trigger_dependencies', \&GetObjectDependencies] ;

AddRule [VIRTUAL], 'o_dependencies_trigger', ['*/*.trigger_dependencies'], BuildOk() ;

# merge the dependencies generated by compiler 

AddPostBuildCommand 'o_local_dependency_merge', ['*/*.o'], 
	sub 
	{
	my ($config, $name, $dependencies, $triggered_dependencies, $argument, $node, $inserted_nodes) = @_ ;

	# merge dependencies in local process graph, end up in digest
	InsertDependencyNodes($node, $inserted_nodes) ;
	return(1, "PostBuildInsertDependencies OK.") ;
	} ;

AddRule 'o_global_dependency_merge', ['*/*.o'],
	undef,
	[
	sub 
		{
		my ($node_name, $config, $tree, $inserted_nodes) = @_ ;

		# merge dependencies in main process graph, end up in the warp file
		$tree->{__PBS_POST_BUILD} =  \&InsertDependencyNodes ;
		
		return 'setting __POST_PBS_BUILD to insert dependencies in the graph'
		}
	] ;
1 ;

